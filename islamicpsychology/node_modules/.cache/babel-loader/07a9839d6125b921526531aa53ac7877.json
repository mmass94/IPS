{"ast":null,"code":"/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule traverseAllChildren\n */\n'use strict';\n\nvar ReactElement = require(\"./ReactElement\");\n\nvar ReactFragment = require(\"./ReactFragment\");\n\nvar ReactInstanceHandles = require(\"./ReactInstanceHandles\");\n\nvar getIteratorFn = require(\"./getIteratorFn\");\n\nvar invariant = require(\"./invariant\");\n\nvar warning = require(\"./warning\");\n\nvar SEPARATOR = ReactInstanceHandles.SEPARATOR;\nvar SUBSEPARATOR = ':';\n/**\n * TODO: Test that a single child and an array with one item have the same key\n * pattern.\n */\n\nvar userProvidedKeyEscaperLookup = {\n  '=': '=0',\n  '.': '=1',\n  ':': '=2'\n};\nvar userProvidedKeyEscapeRegex = /[=.:]/g;\nvar didWarnAboutMaps = false;\n\nfunction userProvidedKeyEscaper(match) {\n  return userProvidedKeyEscaperLookup[match];\n}\n/**\n * Generate a key string that identifies a component within a set.\n *\n * @param {*} component A component that could contain a manual key.\n * @param {number} index Index that is used if a manual key is not provided.\n * @return {string}\n */\n\n\nfunction getComponentKey(component, index) {\n  if (component && component.key != null) {\n    // Explicit key\n    return wrapUserProvidedKey(component.key);\n  } // Implicit key determined by the index in the set\n\n\n  return index.toString(36);\n}\n/**\n * Escape a component key so that it is safe to use in a reactid.\n *\n * @param {*} key Component key to be escaped.\n * @return {string} An escaped string.\n */\n\n\nfunction escapeUserProvidedKey(text) {\n  return ('' + text).replace(userProvidedKeyEscapeRegex, userProvidedKeyEscaper);\n}\n/**\n * Wrap a `key` value explicitly provided by the user to distinguish it from\n * implicitly-generated keys generated by a component's index in its parent.\n *\n * @param {string} key Value of a user-provided `key` attribute\n * @return {string}\n */\n\n\nfunction wrapUserProvidedKey(key) {\n  return '$' + escapeUserProvidedKey(key);\n}\n/**\n * @param {?*} children Children tree container.\n * @param {!string} nameSoFar Name of the key path so far.\n * @param {!number} indexSoFar Number of children encountered until this point.\n * @param {!function} callback Callback to invoke with each child found.\n * @param {?*} traverseContext Used to pass information throughout the traversal\n * process.\n * @return {!number} The number of children in this subtree.\n */\n\n\nfunction traverseAllChildrenImpl(children, nameSoFar, indexSoFar, callback, traverseContext) {\n  var type = typeof children;\n\n  if (type === 'undefined' || type === 'boolean') {\n    // All of the above are perceived as null.\n    children = null;\n  }\n\n  if (children === null || type === 'string' || type === 'number' || ReactElement.isValidElement(children)) {\n    callback(traverseContext, children, // If it's the only child, treat the name as if it was wrapped in an array\n    // so that it's consistent if the number of children grows.\n    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar, indexSoFar);\n    return 1;\n  }\n\n  var child, nextName, nextIndex;\n  var subtreeCount = 0; // Count of children found in the current subtree.\n\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      child = children[i];\n      nextName = (nameSoFar !== '' ? nameSoFar + SUBSEPARATOR : SEPARATOR) + getComponentKey(child, i);\n      nextIndex = indexSoFar + subtreeCount;\n      subtreeCount += traverseAllChildrenImpl(child, nextName, nextIndex, callback, traverseContext);\n    }\n  } else {\n    var iteratorFn = getIteratorFn(children);\n\n    if (iteratorFn) {\n      var iterator = iteratorFn.call(children);\n      var step;\n\n      if (iteratorFn !== children.entries) {\n        var ii = 0;\n\n        while (!(step = iterator.next()).done) {\n          child = step.value;\n          nextName = (nameSoFar !== '' ? nameSoFar + SUBSEPARATOR : SEPARATOR) + getComponentKey(child, ii++);\n          nextIndex = indexSoFar + subtreeCount;\n          subtreeCount += traverseAllChildrenImpl(child, nextName, nextIndex, callback, traverseContext);\n        }\n      } else {\n        if (\"production\" !== process.env.NODE_ENV) {\n          \"production\" !== process.env.NODE_ENV ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.') : null;\n          didWarnAboutMaps = true;\n        } // Iterator will provide entry [k,v] tuples rather than values.\n\n\n        while (!(step = iterator.next()).done) {\n          var entry = step.value;\n\n          if (entry) {\n            child = entry[1];\n            nextName = (nameSoFar !== '' ? nameSoFar + SUBSEPARATOR : SEPARATOR) + wrapUserProvidedKey(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);\n            nextIndex = indexSoFar + subtreeCount;\n            subtreeCount += traverseAllChildrenImpl(child, nextName, nextIndex, callback, traverseContext);\n          }\n        }\n      }\n    } else if (type === 'object') {\n      \"production\" !== process.env.NODE_ENV ? invariant(children.nodeType !== 1, 'traverseAllChildren(...): Encountered an invalid child; DOM ' + 'elements are not valid children of React components.') : invariant(children.nodeType !== 1);\n      var fragment = ReactFragment.extract(children);\n\n      for (var key in fragment) {\n        if (fragment.hasOwnProperty(key)) {\n          child = fragment[key];\n          nextName = (nameSoFar !== '' ? nameSoFar + SUBSEPARATOR : SEPARATOR) + wrapUserProvidedKey(key) + SUBSEPARATOR + getComponentKey(child, 0);\n          nextIndex = indexSoFar + subtreeCount;\n          subtreeCount += traverseAllChildrenImpl(child, nextName, nextIndex, callback, traverseContext);\n        }\n      }\n    }\n  }\n\n  return subtreeCount;\n}\n/**\n * Traverses children that are typically specified as `props.children`, but\n * might also be specified through attributes:\n *\n * - `traverseAllChildren(this.props.children, ...)`\n * - `traverseAllChildren(this.props.leftPanelChildren, ...)`\n *\n * The `traverseContext` is an optional argument that is passed through the\n * entire traversal. It can be used to store accumulations or anything else that\n * the callback might find relevant.\n *\n * @param {?*} children Children tree object.\n * @param {!function} callback To invoke upon traversing each child.\n * @param {?*} traverseContext Context for traversal.\n * @return {!number} The number of children in this subtree.\n */\n\n\nfunction traverseAllChildren(children, callback, traverseContext) {\n  if (children == null) {\n    return 0;\n  }\n\n  return traverseAllChildrenImpl(children, '', 0, callback, traverseContext);\n}\n\nmodule.exports = traverseAllChildren;","map":{"version":3,"sources":["C:/Users/apollo/islamicpsychologyapi/node_modules/react/lib/traverseAllChildren.js"],"names":["ReactElement","require","ReactFragment","ReactInstanceHandles","getIteratorFn","invariant","warning","SEPARATOR","SUBSEPARATOR","userProvidedKeyEscaperLookup","userProvidedKeyEscapeRegex","didWarnAboutMaps","userProvidedKeyEscaper","match","getComponentKey","component","index","key","wrapUserProvidedKey","toString","escapeUserProvidedKey","text","replace","traverseAllChildrenImpl","children","nameSoFar","indexSoFar","callback","traverseContext","type","isValidElement","child","nextName","nextIndex","subtreeCount","Array","isArray","i","length","iteratorFn","iterator","call","step","entries","ii","next","done","value","process","env","NODE_ENV","entry","nodeType","fragment","extract","hasOwnProperty","traverseAllChildren","module","exports"],"mappings":"AAAA;;;;;;;;;;AAWA;;AAEA,IAAIA,YAAY,GAAGC,OAAO,CAAC,gBAAD,CAA1B;;AACA,IAAIC,aAAa,GAAGD,OAAO,CAAC,iBAAD,CAA3B;;AACA,IAAIE,oBAAoB,GAAGF,OAAO,CAAC,wBAAD,CAAlC;;AAEA,IAAIG,aAAa,GAAGH,OAAO,CAAC,iBAAD,CAA3B;;AACA,IAAII,SAAS,GAAGJ,OAAO,CAAC,aAAD,CAAvB;;AACA,IAAIK,OAAO,GAAGL,OAAO,CAAC,WAAD,CAArB;;AAEA,IAAIM,SAAS,GAAGJ,oBAAoB,CAACI,SAArC;AACA,IAAIC,YAAY,GAAG,GAAnB;AAEA;;;;;AAKA,IAAIC,4BAA4B,GAAG;AACjC,OAAK,IAD4B;AAEjC,OAAK,IAF4B;AAGjC,OAAK;AAH4B,CAAnC;AAMA,IAAIC,0BAA0B,GAAG,QAAjC;AAEA,IAAIC,gBAAgB,GAAG,KAAvB;;AAEA,SAASC,sBAAT,CAAgCC,KAAhC,EAAuC;AACrC,SAAOJ,4BAA4B,CAACI,KAAD,CAAnC;AACD;AAED;;;;;;;;;AAOA,SAASC,eAAT,CAAyBC,SAAzB,EAAoCC,KAApC,EAA2C;AACzC,MAAID,SAAS,IAAIA,SAAS,CAACE,GAAV,IAAiB,IAAlC,EAAwC;AACtC;AACA,WAAOC,mBAAmB,CAACH,SAAS,CAACE,GAAX,CAA1B;AACD,GAJwC,CAKzC;;;AACA,SAAOD,KAAK,CAACG,QAAN,CAAe,EAAf,CAAP;AACD;AAED;;;;;;;;AAMA,SAASC,qBAAT,CAA+BC,IAA/B,EAAqC;AACnC,SAAO,CAAC,KAAKA,IAAN,EAAYC,OAAZ,CACLZ,0BADK,EAELE,sBAFK,CAAP;AAID;AAED;;;;;;;;;AAOA,SAASM,mBAAT,CAA6BD,GAA7B,EAAkC;AAChC,SAAO,MAAMG,qBAAqB,CAACH,GAAD,CAAlC;AACD;AAED;;;;;;;;;;;AASA,SAASM,uBAAT,CACEC,QADF,EAEEC,SAFF,EAGEC,UAHF,EAIEC,QAJF,EAKEC,eALF,EAME;AACA,MAAIC,IAAI,GAAG,OAAOL,QAAlB;;AAEA,MAAIK,IAAI,KAAK,WAAT,IAAwBA,IAAI,KAAK,SAArC,EAAgD;AAC9C;AACAL,IAAAA,QAAQ,GAAG,IAAX;AACD;;AAED,MAAIA,QAAQ,KAAK,IAAb,IACAK,IAAI,KAAK,QADT,IAEAA,IAAI,KAAK,QAFT,IAGA7B,YAAY,CAAC8B,cAAb,CAA4BN,QAA5B,CAHJ,EAG2C;AACzCG,IAAAA,QAAQ,CACNC,eADM,EAENJ,QAFM,EAGN;AACA;AACAC,IAAAA,SAAS,KAAK,EAAd,GAAmBlB,SAAS,GAAGO,eAAe,CAACU,QAAD,EAAW,CAAX,CAA9C,GAA8DC,SALxD,EAMNC,UANM,CAAR;AAQA,WAAO,CAAP;AACD;;AAED,MAAIK,KAAJ,EAAWC,QAAX,EAAqBC,SAArB;AACA,MAAIC,YAAY,GAAG,CAAnB,CAxBA,CAwBsB;;AAEtB,MAAIC,KAAK,CAACC,OAAN,CAAcZ,QAAd,CAAJ,EAA6B;AAC3B,SAAK,IAAIa,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGb,QAAQ,CAACc,MAA7B,EAAqCD,CAAC,EAAtC,EAA0C;AACxCN,MAAAA,KAAK,GAAGP,QAAQ,CAACa,CAAD,CAAhB;AACAL,MAAAA,QAAQ,GACN,CAACP,SAAS,KAAK,EAAd,GAAmBA,SAAS,GAAGjB,YAA/B,GAA8CD,SAA/C,IACAO,eAAe,CAACiB,KAAD,EAAQM,CAAR,CAFjB;AAIAJ,MAAAA,SAAS,GAAGP,UAAU,GAAGQ,YAAzB;AACAA,MAAAA,YAAY,IAAIX,uBAAuB,CACrCQ,KADqC,EAErCC,QAFqC,EAGrCC,SAHqC,EAIrCN,QAJqC,EAKrCC,eALqC,CAAvC;AAOD;AACF,GAhBD,MAgBO;AACL,QAAIW,UAAU,GAAGnC,aAAa,CAACoB,QAAD,CAA9B;;AACA,QAAIe,UAAJ,EAAgB;AACd,UAAIC,QAAQ,GAAGD,UAAU,CAACE,IAAX,CAAgBjB,QAAhB,CAAf;AACA,UAAIkB,IAAJ;;AACA,UAAIH,UAAU,KAAKf,QAAQ,CAACmB,OAA5B,EAAqC;AACnC,YAAIC,EAAE,GAAG,CAAT;;AACA,eAAO,CAAC,CAACF,IAAI,GAAGF,QAAQ,CAACK,IAAT,EAAR,EAAyBC,IAAjC,EAAuC;AACrCf,UAAAA,KAAK,GAAGW,IAAI,CAACK,KAAb;AACAf,UAAAA,QAAQ,GACN,CAACP,SAAS,KAAK,EAAd,GAAmBA,SAAS,GAAGjB,YAA/B,GAA8CD,SAA/C,IACAO,eAAe,CAACiB,KAAD,EAAQa,EAAE,EAAV,CAFjB;AAIAX,UAAAA,SAAS,GAAGP,UAAU,GAAGQ,YAAzB;AACAA,UAAAA,YAAY,IAAIX,uBAAuB,CACrCQ,KADqC,EAErCC,QAFqC,EAGrCC,SAHqC,EAIrCN,QAJqC,EAKrCC,eALqC,CAAvC;AAOD;AACF,OAjBD,MAiBO;AACL,YAAI,iBAAiBoB,OAAO,CAACC,GAAR,CAAYC,QAAjC,EAA2C;AACxC,2BAAiBF,OAAO,CAACC,GAAR,CAAYC,QAA7B,GAAwC5C,OAAO,CAC9CK,gBAD8C,EAE9C,iEACA,8DADA,GAEA,qDAJ8C,CAA/C,GAKG,IALJ;AAMAA,UAAAA,gBAAgB,GAAG,IAAnB;AACD,SATI,CAUL;;;AACA,eAAO,CAAC,CAAC+B,IAAI,GAAGF,QAAQ,CAACK,IAAT,EAAR,EAAyBC,IAAjC,EAAuC;AACrC,cAAIK,KAAK,GAAGT,IAAI,CAACK,KAAjB;;AACA,cAAII,KAAJ,EAAW;AACTpB,YAAAA,KAAK,GAAGoB,KAAK,CAAC,CAAD,CAAb;AACAnB,YAAAA,QAAQ,GACN,CAACP,SAAS,KAAK,EAAd,GAAmBA,SAAS,GAAGjB,YAA/B,GAA8CD,SAA/C,IACAW,mBAAmB,CAACiC,KAAK,CAAC,CAAD,CAAN,CADnB,GACgC3C,YADhC,GAEAM,eAAe,CAACiB,KAAD,EAAQ,CAAR,CAHjB;AAKAE,YAAAA,SAAS,GAAGP,UAAU,GAAGQ,YAAzB;AACAA,YAAAA,YAAY,IAAIX,uBAAuB,CACrCQ,KADqC,EAErCC,QAFqC,EAGrCC,SAHqC,EAIrCN,QAJqC,EAKrCC,eALqC,CAAvC;AAOD;AACF;AACF;AACF,KAnDD,MAmDO,IAAIC,IAAI,KAAK,QAAb,EAAuB;AAC3B,uBAAiBmB,OAAO,CAACC,GAAR,CAAYC,QAA7B,GAAwC7C,SAAS,CAChDmB,QAAQ,CAAC4B,QAAT,KAAsB,CAD0B,EAEhD,iEACA,sDAHgD,CAAjD,GAIG/C,SAAS,CAACmB,QAAQ,CAAC4B,QAAT,KAAsB,CAAvB,CAJb;AAKA,UAAIC,QAAQ,GAAGnD,aAAa,CAACoD,OAAd,CAAsB9B,QAAtB,CAAf;;AACA,WAAK,IAAIP,GAAT,IAAgBoC,QAAhB,EAA0B;AACxB,YAAIA,QAAQ,CAACE,cAAT,CAAwBtC,GAAxB,CAAJ,EAAkC;AAChCc,UAAAA,KAAK,GAAGsB,QAAQ,CAACpC,GAAD,CAAhB;AACAe,UAAAA,QAAQ,GACN,CAACP,SAAS,KAAK,EAAd,GAAmBA,SAAS,GAAGjB,YAA/B,GAA8CD,SAA/C,IACAW,mBAAmB,CAACD,GAAD,CADnB,GAC2BT,YAD3B,GAEAM,eAAe,CAACiB,KAAD,EAAQ,CAAR,CAHjB;AAKAE,UAAAA,SAAS,GAAGP,UAAU,GAAGQ,YAAzB;AACAA,UAAAA,YAAY,IAAIX,uBAAuB,CACrCQ,KADqC,EAErCC,QAFqC,EAGrCC,SAHqC,EAIrCN,QAJqC,EAKrCC,eALqC,CAAvC;AAOD;AACF;AACF;AACF;;AAED,SAAOM,YAAP;AACD;AAED;;;;;;;;;;;;;;;;;;AAgBA,SAASsB,mBAAT,CAA6BhC,QAA7B,EAAuCG,QAAvC,EAAiDC,eAAjD,EAAkE;AAChE,MAAIJ,QAAQ,IAAI,IAAhB,EAAsB;AACpB,WAAO,CAAP;AACD;;AAED,SAAOD,uBAAuB,CAACC,QAAD,EAAW,EAAX,EAAe,CAAf,EAAkBG,QAAlB,EAA4BC,eAA5B,CAA9B;AACD;;AAED6B,MAAM,CAACC,OAAP,GAAiBF,mBAAjB","sourcesContent":["/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule traverseAllChildren\n */\n\n'use strict';\n\nvar ReactElement = require(\"./ReactElement\");\nvar ReactFragment = require(\"./ReactFragment\");\nvar ReactInstanceHandles = require(\"./ReactInstanceHandles\");\n\nvar getIteratorFn = require(\"./getIteratorFn\");\nvar invariant = require(\"./invariant\");\nvar warning = require(\"./warning\");\n\nvar SEPARATOR = ReactInstanceHandles.SEPARATOR;\nvar SUBSEPARATOR = ':';\n\n/**\n * TODO: Test that a single child and an array with one item have the same key\n * pattern.\n */\n\nvar userProvidedKeyEscaperLookup = {\n  '=': '=0',\n  '.': '=1',\n  ':': '=2'\n};\n\nvar userProvidedKeyEscapeRegex = /[=.:]/g;\n\nvar didWarnAboutMaps = false;\n\nfunction userProvidedKeyEscaper(match) {\n  return userProvidedKeyEscaperLookup[match];\n}\n\n/**\n * Generate a key string that identifies a component within a set.\n *\n * @param {*} component A component that could contain a manual key.\n * @param {number} index Index that is used if a manual key is not provided.\n * @return {string}\n */\nfunction getComponentKey(component, index) {\n  if (component && component.key != null) {\n    // Explicit key\n    return wrapUserProvidedKey(component.key);\n  }\n  // Implicit key determined by the index in the set\n  return index.toString(36);\n}\n\n/**\n * Escape a component key so that it is safe to use in a reactid.\n *\n * @param {*} key Component key to be escaped.\n * @return {string} An escaped string.\n */\nfunction escapeUserProvidedKey(text) {\n  return ('' + text).replace(\n    userProvidedKeyEscapeRegex,\n    userProvidedKeyEscaper\n  );\n}\n\n/**\n * Wrap a `key` value explicitly provided by the user to distinguish it from\n * implicitly-generated keys generated by a component's index in its parent.\n *\n * @param {string} key Value of a user-provided `key` attribute\n * @return {string}\n */\nfunction wrapUserProvidedKey(key) {\n  return '$' + escapeUserProvidedKey(key);\n}\n\n/**\n * @param {?*} children Children tree container.\n * @param {!string} nameSoFar Name of the key path so far.\n * @param {!number} indexSoFar Number of children encountered until this point.\n * @param {!function} callback Callback to invoke with each child found.\n * @param {?*} traverseContext Used to pass information throughout the traversal\n * process.\n * @return {!number} The number of children in this subtree.\n */\nfunction traverseAllChildrenImpl(\n  children,\n  nameSoFar,\n  indexSoFar,\n  callback,\n  traverseContext\n) {\n  var type = typeof children;\n\n  if (type === 'undefined' || type === 'boolean') {\n    // All of the above are perceived as null.\n    children = null;\n  }\n\n  if (children === null ||\n      type === 'string' ||\n      type === 'number' ||\n      ReactElement.isValidElement(children)) {\n    callback(\n      traverseContext,\n      children,\n      // If it's the only child, treat the name as if it was wrapped in an array\n      // so that it's consistent if the number of children grows.\n      nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar,\n      indexSoFar\n    );\n    return 1;\n  }\n\n  var child, nextName, nextIndex;\n  var subtreeCount = 0; // Count of children found in the current subtree.\n\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      child = children[i];\n      nextName = (\n        (nameSoFar !== '' ? nameSoFar + SUBSEPARATOR : SEPARATOR) +\n        getComponentKey(child, i)\n      );\n      nextIndex = indexSoFar + subtreeCount;\n      subtreeCount += traverseAllChildrenImpl(\n        child,\n        nextName,\n        nextIndex,\n        callback,\n        traverseContext\n      );\n    }\n  } else {\n    var iteratorFn = getIteratorFn(children);\n    if (iteratorFn) {\n      var iterator = iteratorFn.call(children);\n      var step;\n      if (iteratorFn !== children.entries) {\n        var ii = 0;\n        while (!(step = iterator.next()).done) {\n          child = step.value;\n          nextName = (\n            (nameSoFar !== '' ? nameSoFar + SUBSEPARATOR : SEPARATOR) +\n            getComponentKey(child, ii++)\n          );\n          nextIndex = indexSoFar + subtreeCount;\n          subtreeCount += traverseAllChildrenImpl(\n            child,\n            nextName,\n            nextIndex,\n            callback,\n            traverseContext\n          );\n        }\n      } else {\n        if (\"production\" !== process.env.NODE_ENV) {\n          (\"production\" !== process.env.NODE_ENV ? warning(\n            didWarnAboutMaps,\n            'Using Maps as children is not yet fully supported. It is an ' +\n            'experimental feature that might be removed. Convert it to a ' +\n            'sequence / iterable of keyed ReactElements instead.'\n          ) : null);\n          didWarnAboutMaps = true;\n        }\n        // Iterator will provide entry [k,v] tuples rather than values.\n        while (!(step = iterator.next()).done) {\n          var entry = step.value;\n          if (entry) {\n            child = entry[1];\n            nextName = (\n              (nameSoFar !== '' ? nameSoFar + SUBSEPARATOR : SEPARATOR) +\n              wrapUserProvidedKey(entry[0]) + SUBSEPARATOR +\n              getComponentKey(child, 0)\n            );\n            nextIndex = indexSoFar + subtreeCount;\n            subtreeCount += traverseAllChildrenImpl(\n              child,\n              nextName,\n              nextIndex,\n              callback,\n              traverseContext\n            );\n          }\n        }\n      }\n    } else if (type === 'object') {\n      (\"production\" !== process.env.NODE_ENV ? invariant(\n        children.nodeType !== 1,\n        'traverseAllChildren(...): Encountered an invalid child; DOM ' +\n        'elements are not valid children of React components.'\n      ) : invariant(children.nodeType !== 1));\n      var fragment = ReactFragment.extract(children);\n      for (var key in fragment) {\n        if (fragment.hasOwnProperty(key)) {\n          child = fragment[key];\n          nextName = (\n            (nameSoFar !== '' ? nameSoFar + SUBSEPARATOR : SEPARATOR) +\n            wrapUserProvidedKey(key) + SUBSEPARATOR +\n            getComponentKey(child, 0)\n          );\n          nextIndex = indexSoFar + subtreeCount;\n          subtreeCount += traverseAllChildrenImpl(\n            child,\n            nextName,\n            nextIndex,\n            callback,\n            traverseContext\n          );\n        }\n      }\n    }\n  }\n\n  return subtreeCount;\n}\n\n/**\n * Traverses children that are typically specified as `props.children`, but\n * might also be specified through attributes:\n *\n * - `traverseAllChildren(this.props.children, ...)`\n * - `traverseAllChildren(this.props.leftPanelChildren, ...)`\n *\n * The `traverseContext` is an optional argument that is passed through the\n * entire traversal. It can be used to store accumulations or anything else that\n * the callback might find relevant.\n *\n * @param {?*} children Children tree object.\n * @param {!function} callback To invoke upon traversing each child.\n * @param {?*} traverseContext Context for traversal.\n * @return {!number} The number of children in this subtree.\n */\nfunction traverseAllChildren(children, callback, traverseContext) {\n  if (children == null) {\n    return 0;\n  }\n\n  return traverseAllChildrenImpl(children, '', 0, callback, traverseContext);\n}\n\nmodule.exports = traverseAllChildren;\n"]},"metadata":{},"sourceType":"script"}