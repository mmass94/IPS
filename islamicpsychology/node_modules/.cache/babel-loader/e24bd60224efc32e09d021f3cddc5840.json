{"ast":null,"code":"/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactMount\n */\n'use strict';\n\nvar DOMProperty = require(\"./DOMProperty\");\n\nvar ReactBrowserEventEmitter = require(\"./ReactBrowserEventEmitter\");\n\nvar ReactCurrentOwner = require(\"./ReactCurrentOwner\");\n\nvar ReactElement = require(\"./ReactElement\");\n\nvar ReactElementValidator = require(\"./ReactElementValidator\");\n\nvar ReactEmptyComponent = require(\"./ReactEmptyComponent\");\n\nvar ReactInstanceHandles = require(\"./ReactInstanceHandles\");\n\nvar ReactInstanceMap = require(\"./ReactInstanceMap\");\n\nvar ReactMarkupChecksum = require(\"./ReactMarkupChecksum\");\n\nvar ReactPerf = require(\"./ReactPerf\");\n\nvar ReactReconciler = require(\"./ReactReconciler\");\n\nvar ReactUpdateQueue = require(\"./ReactUpdateQueue\");\n\nvar ReactUpdates = require(\"./ReactUpdates\");\n\nvar emptyObject = require(\"./emptyObject\");\n\nvar containsNode = require(\"./containsNode\");\n\nvar getReactRootElementInContainer = require(\"./getReactRootElementInContainer\");\n\nvar instantiateReactComponent = require(\"./instantiateReactComponent\");\n\nvar invariant = require(\"./invariant\");\n\nvar setInnerHTML = require(\"./setInnerHTML\");\n\nvar shouldUpdateReactComponent = require(\"./shouldUpdateReactComponent\");\n\nvar warning = require(\"./warning\");\n\nvar SEPARATOR = ReactInstanceHandles.SEPARATOR;\nvar ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;\nvar nodeCache = {};\nvar ELEMENT_NODE_TYPE = 1;\nvar DOC_NODE_TYPE = 9;\n/** Mapping from reactRootID to React component instance. */\n\nvar instancesByReactRootID = {};\n/** Mapping from reactRootID to `container` nodes. */\n\nvar containersByReactRootID = {};\n\nif (\"production\" !== process.env.NODE_ENV) {\n  /** __DEV__-only mapping from reactRootID to root elements. */\n  var rootElementsByReactRootID = {};\n} // Used to store breadth-first search state in findComponentRoot.\n\n\nvar findComponentRootReusableArray = [];\n/**\n * Finds the index of the first character\n * that's not common between the two given strings.\n *\n * @return {number} the index of the character where the strings diverge\n */\n\nfunction firstDifferenceIndex(string1, string2) {\n  var minLen = Math.min(string1.length, string2.length);\n\n  for (var i = 0; i < minLen; i++) {\n    if (string1.charAt(i) !== string2.charAt(i)) {\n      return i;\n    }\n  }\n\n  return string1.length === string2.length ? -1 : minLen;\n}\n/**\n * @param {DOMElement} container DOM element that may contain a React component.\n * @return {?string} A \"reactRoot\" ID, if a React component is rendered.\n */\n\n\nfunction getReactRootID(container) {\n  var rootElement = getReactRootElementInContainer(container);\n  return rootElement && ReactMount.getID(rootElement);\n}\n/**\n * Accessing node[ATTR_NAME] or calling getAttribute(ATTR_NAME) on a form\n * element can return its control whose name or ID equals ATTR_NAME. All\n * DOM nodes support `getAttributeNode` but this can also get called on\n * other objects so just return '' if we're given something other than a\n * DOM node (such as window).\n *\n * @param {?DOMElement|DOMWindow|DOMDocument|DOMTextNode} node DOM node.\n * @return {string} ID of the supplied `domNode`.\n */\n\n\nfunction getID(node) {\n  var id = internalGetID(node);\n\n  if (id) {\n    if (nodeCache.hasOwnProperty(id)) {\n      var cached = nodeCache[id];\n\n      if (cached !== node) {\n        \"production\" !== process.env.NODE_ENV ? invariant(!isValid(cached, id), 'ReactMount: Two valid but unequal nodes with the same `%s`: %s', ATTR_NAME, id) : invariant(!isValid(cached, id));\n        nodeCache[id] = node;\n      }\n    } else {\n      nodeCache[id] = node;\n    }\n  }\n\n  return id;\n}\n\nfunction internalGetID(node) {\n  // If node is something like a window, document, or text node, none of\n  // which support attributes or a .getAttribute method, gracefully return\n  // the empty string, as if the attribute were missing.\n  return node && node.getAttribute && node.getAttribute(ATTR_NAME) || '';\n}\n/**\n * Sets the React-specific ID of the given node.\n *\n * @param {DOMElement} node The DOM node whose ID will be set.\n * @param {string} id The value of the ID attribute.\n */\n\n\nfunction setID(node, id) {\n  var oldID = internalGetID(node);\n\n  if (oldID !== id) {\n    delete nodeCache[oldID];\n  }\n\n  node.setAttribute(ATTR_NAME, id);\n  nodeCache[id] = node;\n}\n/**\n * Finds the node with the supplied React-generated DOM ID.\n *\n * @param {string} id A React-generated DOM ID.\n * @return {DOMElement} DOM node with the suppled `id`.\n * @internal\n */\n\n\nfunction getNode(id) {\n  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {\n    nodeCache[id] = ReactMount.findReactNodeByID(id);\n  }\n\n  return nodeCache[id];\n}\n/**\n * Finds the node with the supplied public React instance.\n *\n * @param {*} instance A public React instance.\n * @return {?DOMElement} DOM node with the suppled `id`.\n * @internal\n */\n\n\nfunction getNodeFromInstance(instance) {\n  var id = ReactInstanceMap.get(instance)._rootNodeID;\n\n  if (ReactEmptyComponent.isNullComponentID(id)) {\n    return null;\n  }\n\n  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {\n    nodeCache[id] = ReactMount.findReactNodeByID(id);\n  }\n\n  return nodeCache[id];\n}\n/**\n * A node is \"valid\" if it is contained by a currently mounted container.\n *\n * This means that the node does not have to be contained by a document in\n * order to be considered valid.\n *\n * @param {?DOMElement} node The candidate DOM node.\n * @param {string} id The expected ID of the node.\n * @return {boolean} Whether the node is contained by a mounted container.\n */\n\n\nfunction isValid(node, id) {\n  if (node) {\n    \"production\" !== process.env.NODE_ENV ? invariant(internalGetID(node) === id, 'ReactMount: Unexpected modification of `%s`', ATTR_NAME) : invariant(internalGetID(node) === id);\n    var container = ReactMount.findReactContainerForID(id);\n\n    if (container && containsNode(container, node)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * Causes the cache to forget about one React-specific ID.\n *\n * @param {string} id The ID to forget.\n */\n\n\nfunction purgeID(id) {\n  delete nodeCache[id];\n}\n\nvar deepestNodeSoFar = null;\n\nfunction findDeepestCachedAncestorImpl(ancestorID) {\n  var ancestor = nodeCache[ancestorID];\n\n  if (ancestor && isValid(ancestor, ancestorID)) {\n    deepestNodeSoFar = ancestor;\n  } else {\n    // This node isn't populated in the cache, so presumably none of its\n    // descendants are. Break out of the loop.\n    return false;\n  }\n}\n/**\n * Return the deepest cached node whose ID is a prefix of `targetID`.\n */\n\n\nfunction findDeepestCachedAncestor(targetID) {\n  deepestNodeSoFar = null;\n  ReactInstanceHandles.traverseAncestors(targetID, findDeepestCachedAncestorImpl);\n  var foundNode = deepestNodeSoFar;\n  deepestNodeSoFar = null;\n  return foundNode;\n}\n/**\n * Mounts this component and inserts it into the DOM.\n *\n * @param {ReactComponent} componentInstance The instance to mount.\n * @param {string} rootID DOM ID of the root node.\n * @param {DOMElement} container DOM element to mount into.\n * @param {ReactReconcileTransaction} transaction\n * @param {boolean} shouldReuseMarkup If true, do not insert markup\n */\n\n\nfunction mountComponentIntoNode(componentInstance, rootID, container, transaction, shouldReuseMarkup) {\n  var markup = ReactReconciler.mountComponent(componentInstance, rootID, transaction, emptyObject);\n  componentInstance._isTopLevel = true;\n\n  ReactMount._mountImageIntoNode(markup, container, shouldReuseMarkup);\n}\n/**\n * Batched mount.\n *\n * @param {ReactComponent} componentInstance The instance to mount.\n * @param {string} rootID DOM ID of the root node.\n * @param {DOMElement} container DOM element to mount into.\n * @param {boolean} shouldReuseMarkup If true, do not insert markup\n */\n\n\nfunction batchedMountComponentIntoNode(componentInstance, rootID, container, shouldReuseMarkup) {\n  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled();\n  transaction.perform(mountComponentIntoNode, null, componentInstance, rootID, container, transaction, shouldReuseMarkup);\n  ReactUpdates.ReactReconcileTransaction.release(transaction);\n}\n/**\n * Mounting is the process of initializing a React component by creating its\n * representative DOM elements and inserting them into a supplied `container`.\n * Any prior content inside `container` is destroyed in the process.\n *\n *   ReactMount.render(\n *     component,\n *     document.getElementById('container')\n *   );\n *\n *   <div id=\"container\">                   <-- Supplied `container`.\n *     <div data-reactid=\".3\">              <-- Rendered reactRoot of React\n *       // ...                                 component.\n *     </div>\n *   </div>\n *\n * Inside of `container`, the first element rendered is the \"reactRoot\".\n */\n\n\nvar ReactMount = {\n  /** Exposed for debugging purposes **/\n  _instancesByReactRootID: instancesByReactRootID,\n\n  /**\n   * This is a hook provided to support rendering React components while\n   * ensuring that the apparent scroll position of its `container` does not\n   * change.\n   *\n   * @param {DOMElement} container The `container` being rendered into.\n   * @param {function} renderCallback This must be called once to do the render.\n   */\n  scrollMonitor: function (container, renderCallback) {\n    renderCallback();\n  },\n\n  /**\n   * Take a component that's already mounted into the DOM and replace its props\n   * @param {ReactComponent} prevComponent component instance already in the DOM\n   * @param {ReactElement} nextElement component instance to render\n   * @param {DOMElement} container container to render into\n   * @param {?function} callback function triggered on completion\n   */\n  _updateRootComponent: function (prevComponent, nextElement, container, callback) {\n    if (\"production\" !== process.env.NODE_ENV) {\n      ReactElementValidator.checkAndWarnForMutatedProps(nextElement);\n    }\n\n    ReactMount.scrollMonitor(container, function () {\n      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement);\n\n      if (callback) {\n        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);\n      }\n    });\n\n    if (\"production\" !== process.env.NODE_ENV) {\n      // Record the root element in case it later gets transplanted.\n      rootElementsByReactRootID[getReactRootID(container)] = getReactRootElementInContainer(container);\n    }\n\n    return prevComponent;\n  },\n\n  /**\n   * Register a component into the instance map and starts scroll value\n   * monitoring\n   * @param {ReactComponent} nextComponent component instance to render\n   * @param {DOMElement} container container to render into\n   * @return {string} reactRoot ID prefix\n   */\n  _registerComponent: function (nextComponent, container) {\n    \"production\" !== process.env.NODE_ENV ? invariant(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE), '_registerComponent(...): Target container is not a DOM element.') : invariant(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE));\n    ReactBrowserEventEmitter.ensureScrollValueMonitoring();\n    var reactRootID = ReactMount.registerContainer(container);\n    instancesByReactRootID[reactRootID] = nextComponent;\n    return reactRootID;\n  },\n\n  /**\n   * Render a new component into the DOM.\n   * @param {ReactElement} nextElement element to render\n   * @param {DOMElement} container container to render into\n   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion\n   * @return {ReactComponent} nextComponent\n   */\n  _renderNewRootComponent: function (nextElement, container, shouldReuseMarkup) {\n    // Various parts of our code (such as ReactCompositeComponent's\n    // _renderValidatedComponent) assume that calls to render aren't nested;\n    // verify that that's the case.\n    \"production\" !== process.env.NODE_ENV ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate.') : null;\n    var componentInstance = instantiateReactComponent(nextElement, null);\n\n    var reactRootID = ReactMount._registerComponent(componentInstance, container); // The initial render is synchronous but any updates that happen during\n    // rendering, in componentWillMount or componentDidMount, will be batched\n    // according to the current batching strategy.\n\n\n    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, reactRootID, container, shouldReuseMarkup);\n\n    if (\"production\" !== process.env.NODE_ENV) {\n      // Record the root element in case it later gets transplanted.\n      rootElementsByReactRootID[reactRootID] = getReactRootElementInContainer(container);\n    }\n\n    return componentInstance;\n  },\n\n  /**\n   * Renders a React component into the DOM in the supplied `container`.\n   *\n   * If the React component was previously rendered into `container`, this will\n   * perform an update on it and only mutate the DOM as necessary to reflect the\n   * latest React component.\n   *\n   * @param {ReactElement} nextElement Component element to render.\n   * @param {DOMElement} container DOM element to render into.\n   * @param {?function} callback function triggered on completion\n   * @return {ReactComponent} Component instance rendered in `container`.\n   */\n  render: function (nextElement, container, callback) {\n    \"production\" !== process.env.NODE_ENV ? invariant(ReactElement.isValidElement(nextElement), 'React.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing an element string, make sure to instantiate ' + 'it by passing it to React.createElement.' : typeof nextElement === 'function' ? ' Instead of passing a component class, make sure to instantiate ' + 'it by passing it to React.createElement.' : // Check if it quacks like an element\n    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : invariant(ReactElement.isValidElement(nextElement));\n    var prevComponent = instancesByReactRootID[getReactRootID(container)];\n\n    if (prevComponent) {\n      var prevElement = prevComponent._currentElement;\n\n      if (shouldUpdateReactComponent(prevElement, nextElement)) {\n        return ReactMount._updateRootComponent(prevComponent, nextElement, container, callback).getPublicInstance();\n      } else {\n        ReactMount.unmountComponentAtNode(container);\n      }\n    }\n\n    var reactRootElement = getReactRootElementInContainer(container);\n    var containerHasReactMarkup = reactRootElement && ReactMount.isRenderedByReact(reactRootElement);\n\n    if (\"production\" !== process.env.NODE_ENV) {\n      if (!containerHasReactMarkup || reactRootElement.nextSibling) {\n        var rootElementSibling = reactRootElement;\n\n        while (rootElementSibling) {\n          if (ReactMount.isRenderedByReact(rootElementSibling)) {\n            \"production\" !== process.env.NODE_ENV ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : null;\n            break;\n          }\n\n          rootElementSibling = rootElementSibling.nextSibling;\n        }\n      }\n    }\n\n    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent;\n\n    var component = ReactMount._renderNewRootComponent(nextElement, container, shouldReuseMarkup).getPublicInstance();\n\n    if (callback) {\n      callback.call(component);\n    }\n\n    return component;\n  },\n\n  /**\n   * Constructs a component instance of `constructor` with `initialProps` and\n   * renders it into the supplied `container`.\n   *\n   * @param {function} constructor React component constructor.\n   * @param {?object} props Initial props of the component instance.\n   * @param {DOMElement} container DOM element to render into.\n   * @return {ReactComponent} Component instance rendered in `container`.\n   */\n  constructAndRenderComponent: function (constructor, props, container) {\n    var element = ReactElement.createElement(constructor, props);\n    return ReactMount.render(element, container);\n  },\n\n  /**\n   * Constructs a component instance of `constructor` with `initialProps` and\n   * renders it into a container node identified by supplied `id`.\n   *\n   * @param {function} componentConstructor React component constructor\n   * @param {?object} props Initial props of the component instance.\n   * @param {string} id ID of the DOM element to render into.\n   * @return {ReactComponent} Component instance rendered in the container node.\n   */\n  constructAndRenderComponentByID: function (constructor, props, id) {\n    var domNode = document.getElementById(id);\n    \"production\" !== process.env.NODE_ENV ? invariant(domNode, 'Tried to get element with id of \"%s\" but it is not present on the page.', id) : invariant(domNode);\n    return ReactMount.constructAndRenderComponent(constructor, props, domNode);\n  },\n\n  /**\n   * Registers a container node into which React components will be rendered.\n   * This also creates the \"reactRoot\" ID that will be assigned to the element\n   * rendered within.\n   *\n   * @param {DOMElement} container DOM element to register as a container.\n   * @return {string} The \"reactRoot\" ID of elements rendered within.\n   */\n  registerContainer: function (container) {\n    var reactRootID = getReactRootID(container);\n\n    if (reactRootID) {\n      // If one exists, make sure it is a valid \"reactRoot\" ID.\n      reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID);\n    }\n\n    if (!reactRootID) {\n      // No valid \"reactRoot\" ID found, create one.\n      reactRootID = ReactInstanceHandles.createReactRootID();\n    }\n\n    containersByReactRootID[reactRootID] = container;\n    return reactRootID;\n  },\n\n  /**\n   * Unmounts and destroys the React component rendered in the `container`.\n   *\n   * @param {DOMElement} container DOM element containing a React component.\n   * @return {boolean} True if a component was found in and unmounted from\n   *                   `container`\n   */\n  unmountComponentAtNode: function (container) {\n    // Various parts of our code (such as ReactCompositeComponent's\n    // _renderValidatedComponent) assume that calls to render aren't nested;\n    // verify that that's the case. (Strictly speaking, unmounting won't cause a\n    // render but we still don't expect to be in a render call here.)\n    \"production\" !== process.env.NODE_ENV ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function of ' + 'props and state; triggering nested component updates from render is ' + 'not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate.') : null;\n    \"production\" !== process.env.NODE_ENV ? invariant(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE), 'unmountComponentAtNode(...): Target container is not a DOM element.') : invariant(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE));\n    var reactRootID = getReactRootID(container);\n    var component = instancesByReactRootID[reactRootID];\n\n    if (!component) {\n      return false;\n    }\n\n    ReactMount.unmountComponentFromNode(component, container);\n    delete instancesByReactRootID[reactRootID];\n    delete containersByReactRootID[reactRootID];\n\n    if (\"production\" !== process.env.NODE_ENV) {\n      delete rootElementsByReactRootID[reactRootID];\n    }\n\n    return true;\n  },\n\n  /**\n   * Unmounts a component and removes it from the DOM.\n   *\n   * @param {ReactComponent} instance React component instance.\n   * @param {DOMElement} container DOM element to unmount from.\n   * @final\n   * @internal\n   * @see {ReactMount.unmountComponentAtNode}\n   */\n  unmountComponentFromNode: function (instance, container) {\n    ReactReconciler.unmountComponent(instance);\n\n    if (container.nodeType === DOC_NODE_TYPE) {\n      container = container.documentElement;\n    } // http://jsperf.com/emptying-a-node\n\n\n    while (container.lastChild) {\n      container.removeChild(container.lastChild);\n    }\n  },\n\n  /**\n   * Finds the container DOM element that contains React component to which the\n   * supplied DOM `id` belongs.\n   *\n   * @param {string} id The ID of an element rendered by a React component.\n   * @return {?DOMElement} DOM element that contains the `id`.\n   */\n  findReactContainerForID: function (id) {\n    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(id);\n    var container = containersByReactRootID[reactRootID];\n\n    if (\"production\" !== process.env.NODE_ENV) {\n      var rootElement = rootElementsByReactRootID[reactRootID];\n\n      if (rootElement && rootElement.parentNode !== container) {\n        \"production\" !== process.env.NODE_ENV ? invariant( // Call internalGetID here because getID calls isValid which calls\n        // findReactContainerForID (this function).\n        internalGetID(rootElement) === reactRootID, 'ReactMount: Root element ID differed from reactRootID.') : invariant( // Call internalGetID here because getID calls isValid which calls\n        // findReactContainerForID (this function).\n        internalGetID(rootElement) === reactRootID);\n        var containerChild = container.firstChild;\n\n        if (containerChild && reactRootID === internalGetID(containerChild)) {\n          // If the container has a new child with the same ID as the old\n          // root element, then rootElementsByReactRootID[reactRootID] is\n          // just stale and needs to be updated. The case that deserves a\n          // warning is when the container is empty.\n          rootElementsByReactRootID[reactRootID] = containerChild;\n        } else {\n          \"production\" !== process.env.NODE_ENV ? warning(false, 'ReactMount: Root element has been removed from its original ' + 'container. New container:', rootElement.parentNode) : null;\n        }\n      }\n    }\n\n    return container;\n  },\n\n  /**\n   * Finds an element rendered by React with the supplied ID.\n   *\n   * @param {string} id ID of a DOM node in the React component.\n   * @return {DOMElement} Root DOM node of the React component.\n   */\n  findReactNodeByID: function (id) {\n    var reactRoot = ReactMount.findReactContainerForID(id);\n    return ReactMount.findComponentRoot(reactRoot, id);\n  },\n\n  /**\n   * True if the supplied `node` is rendered by React.\n   *\n   * @param {*} node DOM Element to check.\n   * @return {boolean} True if the DOM Element appears to be rendered by React.\n   * @internal\n   */\n  isRenderedByReact: function (node) {\n    if (node.nodeType !== 1) {\n      // Not a DOMElement, therefore not a React component\n      return false;\n    }\n\n    var id = ReactMount.getID(node);\n    return id ? id.charAt(0) === SEPARATOR : false;\n  },\n\n  /**\n   * Traverses up the ancestors of the supplied node to find a node that is a\n   * DOM representation of a React component.\n   *\n   * @param {*} node\n   * @return {?DOMEventTarget}\n   * @internal\n   */\n  getFirstReactDOM: function (node) {\n    var current = node;\n\n    while (current && current.parentNode !== current) {\n      if (ReactMount.isRenderedByReact(current)) {\n        return current;\n      }\n\n      current = current.parentNode;\n    }\n\n    return null;\n  },\n\n  /**\n   * Finds a node with the supplied `targetID` inside of the supplied\n   * `ancestorNode`.  Exploits the ID naming scheme to perform the search\n   * quickly.\n   *\n   * @param {DOMEventTarget} ancestorNode Search from this root.\n   * @pararm {string} targetID ID of the DOM representation of the component.\n   * @return {DOMEventTarget} DOM node with the supplied `targetID`.\n   * @internal\n   */\n  findComponentRoot: function (ancestorNode, targetID) {\n    var firstChildren = findComponentRootReusableArray;\n    var childIndex = 0;\n    var deepestAncestor = findDeepestCachedAncestor(targetID) || ancestorNode;\n    firstChildren[0] = deepestAncestor.firstChild;\n    firstChildren.length = 1;\n\n    while (childIndex < firstChildren.length) {\n      var child = firstChildren[childIndex++];\n      var targetChild;\n\n      while (child) {\n        var childID = ReactMount.getID(child);\n\n        if (childID) {\n          // Even if we find the node we're looking for, we finish looping\n          // through its siblings to ensure they're cached so that we don't have\n          // to revisit this node again. Otherwise, we make n^2 calls to getID\n          // when visiting the many children of a single node in order.\n          if (targetID === childID) {\n            targetChild = child;\n          } else if (ReactInstanceHandles.isAncestorIDOf(childID, targetID)) {\n            // If we find a child whose ID is an ancestor of the given ID,\n            // then we can be sure that we only want to search the subtree\n            // rooted at this child, so we can throw out the rest of the\n            // search state.\n            firstChildren.length = childIndex = 0;\n            firstChildren.push(child.firstChild);\n          }\n        } else {\n          // If this child had no ID, then there's a chance that it was\n          // injected automatically by the browser, as when a `<table>`\n          // element sprouts an extra `<tbody>` child as a side effect of\n          // `.innerHTML` parsing. Optimistically continue down this\n          // branch, but not before examining the other siblings.\n          firstChildren.push(child.firstChild);\n        }\n\n        child = child.nextSibling;\n      }\n\n      if (targetChild) {\n        // Emptying firstChildren/findComponentRootReusableArray is\n        // not necessary for correctness, but it helps the GC reclaim\n        // any nodes that were left at the end of the search.\n        firstChildren.length = 0;\n        return targetChild;\n      }\n    }\n\n    firstChildren.length = 0;\n    \"production\" !== process.env.NODE_ENV ? invariant(false, 'findComponentRoot(..., %s): Unable to find element. This probably ' + 'means the DOM was unexpectedly mutated (e.g., by the browser), ' + 'usually due to forgetting a <tbody> when using tables, nesting tags ' + 'like <form>, <p>, or <a>, or using non-SVG elements in an <svg> ' + 'parent. ' + 'Try inspecting the child nodes of the element with React ID `%s`.', targetID, ReactMount.getID(ancestorNode)) : invariant(false);\n  },\n  _mountImageIntoNode: function (markup, container, shouldReuseMarkup) {\n    \"production\" !== process.env.NODE_ENV ? invariant(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE), 'mountComponentIntoNode(...): Target container is not valid.') : invariant(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE));\n\n    if (shouldReuseMarkup) {\n      var rootElement = getReactRootElementInContainer(container);\n\n      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {\n        return;\n      } else {\n        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);\n        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);\n        var rootMarkup = rootElement.outerHTML;\n        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);\n        var diffIndex = firstDifferenceIndex(markup, rootMarkup);\n        var difference = ' (client) ' + markup.substring(diffIndex - 20, diffIndex + 20) + '\\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);\n        \"production\" !== process.env.NODE_ENV ? invariant(container.nodeType !== DOC_NODE_TYPE, 'You\\'re trying to render a component to the document using ' + 'server rendering but the checksum was invalid. This usually ' + 'means you rendered a different component type or props on ' + 'the client from the one on the server, or your render() ' + 'methods are impure. React cannot handle this case due to ' + 'cross-browser quirks by rendering at the document root. You ' + 'should look for environment dependent code in your components ' + 'and ensure the props are the same client and server side:\\n%s', difference) : invariant(container.nodeType !== DOC_NODE_TYPE);\n\n        if (\"production\" !== process.env.NODE_ENV) {\n          \"production\" !== process.env.NODE_ENV ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\\n%s', difference) : null;\n        }\n      }\n    }\n\n    \"production\" !== process.env.NODE_ENV ? invariant(container.nodeType !== DOC_NODE_TYPE, 'You\\'re trying to render a component to the document but ' + 'you didn\\'t use server rendering. We can\\'t do this ' + 'without using server rendering due to cross-browser quirks. ' + 'See React.renderToString() for server rendering.') : invariant(container.nodeType !== DOC_NODE_TYPE);\n    setInnerHTML(container, markup);\n  },\n\n  /**\n   * React ID utilities.\n   */\n  getReactRootID: getReactRootID,\n  getID: getID,\n  setID: setID,\n  getNode: getNode,\n  getNodeFromInstance: getNodeFromInstance,\n  purgeID: purgeID\n};\nReactPerf.measureMethods(ReactMount, 'ReactMount', {\n  _renderNewRootComponent: '_renderNewRootComponent',\n  _mountImageIntoNode: '_mountImageIntoNode'\n});\nmodule.exports = ReactMount;","map":{"version":3,"sources":["C:/Users/apollo/islamicpsychologyapi/node_modules/react/lib/ReactMount.js"],"names":["DOMProperty","require","ReactBrowserEventEmitter","ReactCurrentOwner","ReactElement","ReactElementValidator","ReactEmptyComponent","ReactInstanceHandles","ReactInstanceMap","ReactMarkupChecksum","ReactPerf","ReactReconciler","ReactUpdateQueue","ReactUpdates","emptyObject","containsNode","getReactRootElementInContainer","instantiateReactComponent","invariant","setInnerHTML","shouldUpdateReactComponent","warning","SEPARATOR","ATTR_NAME","ID_ATTRIBUTE_NAME","nodeCache","ELEMENT_NODE_TYPE","DOC_NODE_TYPE","instancesByReactRootID","containersByReactRootID","process","env","NODE_ENV","rootElementsByReactRootID","findComponentRootReusableArray","firstDifferenceIndex","string1","string2","minLen","Math","min","length","i","charAt","getReactRootID","container","rootElement","ReactMount","getID","node","id","internalGetID","hasOwnProperty","cached","isValid","getAttribute","setID","oldID","setAttribute","getNode","findReactNodeByID","getNodeFromInstance","instance","get","_rootNodeID","isNullComponentID","findReactContainerForID","purgeID","deepestNodeSoFar","findDeepestCachedAncestorImpl","ancestorID","ancestor","findDeepestCachedAncestor","targetID","traverseAncestors","foundNode","mountComponentIntoNode","componentInstance","rootID","transaction","shouldReuseMarkup","markup","mountComponent","_isTopLevel","_mountImageIntoNode","batchedMountComponentIntoNode","ReactReconcileTransaction","getPooled","perform","release","_instancesByReactRootID","scrollMonitor","renderCallback","_updateRootComponent","prevComponent","nextElement","callback","checkAndWarnForMutatedProps","enqueueElementInternal","enqueueCallbackInternal","_registerComponent","nextComponent","nodeType","ensureScrollValueMonitoring","reactRootID","registerContainer","_renderNewRootComponent","current","batchedUpdates","render","isValidElement","props","undefined","prevElement","_currentElement","getPublicInstance","unmountComponentAtNode","reactRootElement","containerHasReactMarkup","isRenderedByReact","nextSibling","rootElementSibling","component","call","constructAndRenderComponent","constructor","element","createElement","constructAndRenderComponentByID","domNode","document","getElementById","getReactRootIDFromNodeID","createReactRootID","unmountComponentFromNode","unmountComponent","documentElement","lastChild","removeChild","parentNode","containerChild","firstChild","reactRoot","findComponentRoot","getFirstReactDOM","ancestorNode","firstChildren","childIndex","deepestAncestor","child","targetChild","childID","isAncestorIDOf","push","canReuseMarkup","checksum","CHECKSUM_ATTR_NAME","removeAttribute","rootMarkup","outerHTML","diffIndex","difference","substring","measureMethods","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactMount\n */\n\n'use strict';\n\nvar DOMProperty = require(\"./DOMProperty\");\nvar ReactBrowserEventEmitter = require(\"./ReactBrowserEventEmitter\");\nvar ReactCurrentOwner = require(\"./ReactCurrentOwner\");\nvar ReactElement = require(\"./ReactElement\");\nvar ReactElementValidator = require(\"./ReactElementValidator\");\nvar ReactEmptyComponent = require(\"./ReactEmptyComponent\");\nvar ReactInstanceHandles = require(\"./ReactInstanceHandles\");\nvar ReactInstanceMap = require(\"./ReactInstanceMap\");\nvar ReactMarkupChecksum = require(\"./ReactMarkupChecksum\");\nvar ReactPerf = require(\"./ReactPerf\");\nvar ReactReconciler = require(\"./ReactReconciler\");\nvar ReactUpdateQueue = require(\"./ReactUpdateQueue\");\nvar ReactUpdates = require(\"./ReactUpdates\");\n\nvar emptyObject = require(\"./emptyObject\");\nvar containsNode = require(\"./containsNode\");\nvar getReactRootElementInContainer = require(\"./getReactRootElementInContainer\");\nvar instantiateReactComponent = require(\"./instantiateReactComponent\");\nvar invariant = require(\"./invariant\");\nvar setInnerHTML = require(\"./setInnerHTML\");\nvar shouldUpdateReactComponent = require(\"./shouldUpdateReactComponent\");\nvar warning = require(\"./warning\");\n\nvar SEPARATOR = ReactInstanceHandles.SEPARATOR;\n\nvar ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;\nvar nodeCache = {};\n\nvar ELEMENT_NODE_TYPE = 1;\nvar DOC_NODE_TYPE = 9;\n\n/** Mapping from reactRootID to React component instance. */\nvar instancesByReactRootID = {};\n\n/** Mapping from reactRootID to `container` nodes. */\nvar containersByReactRootID = {};\n\nif (\"production\" !== process.env.NODE_ENV) {\n  /** __DEV__-only mapping from reactRootID to root elements. */\n  var rootElementsByReactRootID = {};\n}\n\n// Used to store breadth-first search state in findComponentRoot.\nvar findComponentRootReusableArray = [];\n\n/**\n * Finds the index of the first character\n * that's not common between the two given strings.\n *\n * @return {number} the index of the character where the strings diverge\n */\nfunction firstDifferenceIndex(string1, string2) {\n  var minLen = Math.min(string1.length, string2.length);\n  for (var i = 0; i < minLen; i++) {\n    if (string1.charAt(i) !== string2.charAt(i)) {\n      return i;\n    }\n  }\n  return string1.length === string2.length ? -1 : minLen;\n}\n\n/**\n * @param {DOMElement} container DOM element that may contain a React component.\n * @return {?string} A \"reactRoot\" ID, if a React component is rendered.\n */\nfunction getReactRootID(container) {\n  var rootElement = getReactRootElementInContainer(container);\n  return rootElement && ReactMount.getID(rootElement);\n}\n\n/**\n * Accessing node[ATTR_NAME] or calling getAttribute(ATTR_NAME) on a form\n * element can return its control whose name or ID equals ATTR_NAME. All\n * DOM nodes support `getAttributeNode` but this can also get called on\n * other objects so just return '' if we're given something other than a\n * DOM node (such as window).\n *\n * @param {?DOMElement|DOMWindow|DOMDocument|DOMTextNode} node DOM node.\n * @return {string} ID of the supplied `domNode`.\n */\nfunction getID(node) {\n  var id = internalGetID(node);\n  if (id) {\n    if (nodeCache.hasOwnProperty(id)) {\n      var cached = nodeCache[id];\n      if (cached !== node) {\n        (\"production\" !== process.env.NODE_ENV ? invariant(\n          !isValid(cached, id),\n          'ReactMount: Two valid but unequal nodes with the same `%s`: %s',\n          ATTR_NAME, id\n        ) : invariant(!isValid(cached, id)));\n\n        nodeCache[id] = node;\n      }\n    } else {\n      nodeCache[id] = node;\n    }\n  }\n\n  return id;\n}\n\nfunction internalGetID(node) {\n  // If node is something like a window, document, or text node, none of\n  // which support attributes or a .getAttribute method, gracefully return\n  // the empty string, as if the attribute were missing.\n  return node && node.getAttribute && node.getAttribute(ATTR_NAME) || '';\n}\n\n/**\n * Sets the React-specific ID of the given node.\n *\n * @param {DOMElement} node The DOM node whose ID will be set.\n * @param {string} id The value of the ID attribute.\n */\nfunction setID(node, id) {\n  var oldID = internalGetID(node);\n  if (oldID !== id) {\n    delete nodeCache[oldID];\n  }\n  node.setAttribute(ATTR_NAME, id);\n  nodeCache[id] = node;\n}\n\n/**\n * Finds the node with the supplied React-generated DOM ID.\n *\n * @param {string} id A React-generated DOM ID.\n * @return {DOMElement} DOM node with the suppled `id`.\n * @internal\n */\nfunction getNode(id) {\n  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {\n    nodeCache[id] = ReactMount.findReactNodeByID(id);\n  }\n  return nodeCache[id];\n}\n\n/**\n * Finds the node with the supplied public React instance.\n *\n * @param {*} instance A public React instance.\n * @return {?DOMElement} DOM node with the suppled `id`.\n * @internal\n */\nfunction getNodeFromInstance(instance) {\n  var id = ReactInstanceMap.get(instance)._rootNodeID;\n  if (ReactEmptyComponent.isNullComponentID(id)) {\n    return null;\n  }\n  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {\n    nodeCache[id] = ReactMount.findReactNodeByID(id);\n  }\n  return nodeCache[id];\n}\n\n/**\n * A node is \"valid\" if it is contained by a currently mounted container.\n *\n * This means that the node does not have to be contained by a document in\n * order to be considered valid.\n *\n * @param {?DOMElement} node The candidate DOM node.\n * @param {string} id The expected ID of the node.\n * @return {boolean} Whether the node is contained by a mounted container.\n */\nfunction isValid(node, id) {\n  if (node) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      internalGetID(node) === id,\n      'ReactMount: Unexpected modification of `%s`',\n      ATTR_NAME\n    ) : invariant(internalGetID(node) === id));\n\n    var container = ReactMount.findReactContainerForID(id);\n    if (container && containsNode(container, node)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Causes the cache to forget about one React-specific ID.\n *\n * @param {string} id The ID to forget.\n */\nfunction purgeID(id) {\n  delete nodeCache[id];\n}\n\nvar deepestNodeSoFar = null;\nfunction findDeepestCachedAncestorImpl(ancestorID) {\n  var ancestor = nodeCache[ancestorID];\n  if (ancestor && isValid(ancestor, ancestorID)) {\n    deepestNodeSoFar = ancestor;\n  } else {\n    // This node isn't populated in the cache, so presumably none of its\n    // descendants are. Break out of the loop.\n    return false;\n  }\n}\n\n/**\n * Return the deepest cached node whose ID is a prefix of `targetID`.\n */\nfunction findDeepestCachedAncestor(targetID) {\n  deepestNodeSoFar = null;\n  ReactInstanceHandles.traverseAncestors(\n    targetID,\n    findDeepestCachedAncestorImpl\n  );\n\n  var foundNode = deepestNodeSoFar;\n  deepestNodeSoFar = null;\n  return foundNode;\n}\n\n/**\n * Mounts this component and inserts it into the DOM.\n *\n * @param {ReactComponent} componentInstance The instance to mount.\n * @param {string} rootID DOM ID of the root node.\n * @param {DOMElement} container DOM element to mount into.\n * @param {ReactReconcileTransaction} transaction\n * @param {boolean} shouldReuseMarkup If true, do not insert markup\n */\nfunction mountComponentIntoNode(\n    componentInstance,\n    rootID,\n    container,\n    transaction,\n    shouldReuseMarkup) {\n  var markup = ReactReconciler.mountComponent(\n    componentInstance, rootID, transaction, emptyObject\n  );\n  componentInstance._isTopLevel = true;\n  ReactMount._mountImageIntoNode(markup, container, shouldReuseMarkup);\n}\n\n/**\n * Batched mount.\n *\n * @param {ReactComponent} componentInstance The instance to mount.\n * @param {string} rootID DOM ID of the root node.\n * @param {DOMElement} container DOM element to mount into.\n * @param {boolean} shouldReuseMarkup If true, do not insert markup\n */\nfunction batchedMountComponentIntoNode(\n    componentInstance,\n    rootID,\n    container,\n    shouldReuseMarkup) {\n  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled();\n  transaction.perform(\n    mountComponentIntoNode,\n    null,\n    componentInstance,\n    rootID,\n    container,\n    transaction,\n    shouldReuseMarkup\n  );\n  ReactUpdates.ReactReconcileTransaction.release(transaction);\n}\n\n/**\n * Mounting is the process of initializing a React component by creating its\n * representative DOM elements and inserting them into a supplied `container`.\n * Any prior content inside `container` is destroyed in the process.\n *\n *   ReactMount.render(\n *     component,\n *     document.getElementById('container')\n *   );\n *\n *   <div id=\"container\">                   <-- Supplied `container`.\n *     <div data-reactid=\".3\">              <-- Rendered reactRoot of React\n *       // ...                                 component.\n *     </div>\n *   </div>\n *\n * Inside of `container`, the first element rendered is the \"reactRoot\".\n */\nvar ReactMount = {\n  /** Exposed for debugging purposes **/\n  _instancesByReactRootID: instancesByReactRootID,\n\n  /**\n   * This is a hook provided to support rendering React components while\n   * ensuring that the apparent scroll position of its `container` does not\n   * change.\n   *\n   * @param {DOMElement} container The `container` being rendered into.\n   * @param {function} renderCallback This must be called once to do the render.\n   */\n  scrollMonitor: function(container, renderCallback) {\n    renderCallback();\n  },\n\n  /**\n   * Take a component that's already mounted into the DOM and replace its props\n   * @param {ReactComponent} prevComponent component instance already in the DOM\n   * @param {ReactElement} nextElement component instance to render\n   * @param {DOMElement} container container to render into\n   * @param {?function} callback function triggered on completion\n   */\n  _updateRootComponent: function(\n      prevComponent,\n      nextElement,\n      container,\n      callback) {\n    if (\"production\" !== process.env.NODE_ENV) {\n      ReactElementValidator.checkAndWarnForMutatedProps(nextElement);\n    }\n\n    ReactMount.scrollMonitor(container, function() {\n      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement);\n      if (callback) {\n        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);\n      }\n    });\n\n    if (\"production\" !== process.env.NODE_ENV) {\n      // Record the root element in case it later gets transplanted.\n      rootElementsByReactRootID[getReactRootID(container)] =\n        getReactRootElementInContainer(container);\n    }\n\n    return prevComponent;\n  },\n\n  /**\n   * Register a component into the instance map and starts scroll value\n   * monitoring\n   * @param {ReactComponent} nextComponent component instance to render\n   * @param {DOMElement} container container to render into\n   * @return {string} reactRoot ID prefix\n   */\n  _registerComponent: function(nextComponent, container) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      container && (\n        (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE)\n      ),\n      '_registerComponent(...): Target container is not a DOM element.'\n    ) : invariant(container && (\n      (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE)\n    )));\n\n    ReactBrowserEventEmitter.ensureScrollValueMonitoring();\n\n    var reactRootID = ReactMount.registerContainer(container);\n    instancesByReactRootID[reactRootID] = nextComponent;\n    return reactRootID;\n  },\n\n  /**\n   * Render a new component into the DOM.\n   * @param {ReactElement} nextElement element to render\n   * @param {DOMElement} container container to render into\n   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion\n   * @return {ReactComponent} nextComponent\n   */\n  _renderNewRootComponent: function(\n    nextElement,\n    container,\n    shouldReuseMarkup\n  ) {\n    // Various parts of our code (such as ReactCompositeComponent's\n    // _renderValidatedComponent) assume that calls to render aren't nested;\n    // verify that that's the case.\n    (\"production\" !== process.env.NODE_ENV ? warning(\n      ReactCurrentOwner.current == null,\n      '_renderNewRootComponent(): Render methods should be a pure function ' +\n      'of props and state; triggering nested component updates from ' +\n      'render is not allowed. If necessary, trigger nested updates in ' +\n      'componentDidUpdate.'\n    ) : null);\n\n    var componentInstance = instantiateReactComponent(nextElement, null);\n    var reactRootID = ReactMount._registerComponent(\n      componentInstance,\n      container\n    );\n\n    // The initial render is synchronous but any updates that happen during\n    // rendering, in componentWillMount or componentDidMount, will be batched\n    // according to the current batching strategy.\n\n    ReactUpdates.batchedUpdates(\n      batchedMountComponentIntoNode,\n      componentInstance,\n      reactRootID,\n      container,\n      shouldReuseMarkup\n    );\n\n    if (\"production\" !== process.env.NODE_ENV) {\n      // Record the root element in case it later gets transplanted.\n      rootElementsByReactRootID[reactRootID] =\n        getReactRootElementInContainer(container);\n    }\n\n    return componentInstance;\n  },\n\n  /**\n   * Renders a React component into the DOM in the supplied `container`.\n   *\n   * If the React component was previously rendered into `container`, this will\n   * perform an update on it and only mutate the DOM as necessary to reflect the\n   * latest React component.\n   *\n   * @param {ReactElement} nextElement Component element to render.\n   * @param {DOMElement} container DOM element to render into.\n   * @param {?function} callback function triggered on completion\n   * @return {ReactComponent} Component instance rendered in `container`.\n   */\n  render: function(nextElement, container, callback) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      ReactElement.isValidElement(nextElement),\n      'React.render(): Invalid component element.%s',\n      (\n        typeof nextElement === 'string' ?\n          ' Instead of passing an element string, make sure to instantiate ' +\n          'it by passing it to React.createElement.' :\n        typeof nextElement === 'function' ?\n          ' Instead of passing a component class, make sure to instantiate ' +\n          'it by passing it to React.createElement.' :\n        // Check if it quacks like an element\n        nextElement != null && nextElement.props !== undefined ?\n          ' This may be caused by unintentionally loading two independent ' +\n          'copies of React.' :\n          ''\n      )\n    ) : invariant(ReactElement.isValidElement(nextElement)));\n\n    var prevComponent = instancesByReactRootID[getReactRootID(container)];\n\n    if (prevComponent) {\n      var prevElement = prevComponent._currentElement;\n      if (shouldUpdateReactComponent(prevElement, nextElement)) {\n        return ReactMount._updateRootComponent(\n          prevComponent,\n          nextElement,\n          container,\n          callback\n        ).getPublicInstance();\n      } else {\n        ReactMount.unmountComponentAtNode(container);\n      }\n    }\n\n    var reactRootElement = getReactRootElementInContainer(container);\n    var containerHasReactMarkup =\n      reactRootElement && ReactMount.isRenderedByReact(reactRootElement);\n\n    if (\"production\" !== process.env.NODE_ENV) {\n      if (!containerHasReactMarkup || reactRootElement.nextSibling) {\n        var rootElementSibling = reactRootElement;\n        while (rootElementSibling) {\n          if (ReactMount.isRenderedByReact(rootElementSibling)) {\n            (\"production\" !== process.env.NODE_ENV ? warning(\n              false,\n              'render(): Target node has markup rendered by React, but there ' +\n              'are unrelated nodes as well. This is most commonly caused by ' +\n              'white-space inserted around server-rendered markup.'\n            ) : null);\n            break;\n          }\n\n          rootElementSibling = rootElementSibling.nextSibling;\n        }\n      }\n    }\n\n    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent;\n\n    var component = ReactMount._renderNewRootComponent(\n      nextElement,\n      container,\n      shouldReuseMarkup\n    ).getPublicInstance();\n    if (callback) {\n      callback.call(component);\n    }\n    return component;\n  },\n\n  /**\n   * Constructs a component instance of `constructor` with `initialProps` and\n   * renders it into the supplied `container`.\n   *\n   * @param {function} constructor React component constructor.\n   * @param {?object} props Initial props of the component instance.\n   * @param {DOMElement} container DOM element to render into.\n   * @return {ReactComponent} Component instance rendered in `container`.\n   */\n  constructAndRenderComponent: function(constructor, props, container) {\n    var element = ReactElement.createElement(constructor, props);\n    return ReactMount.render(element, container);\n  },\n\n  /**\n   * Constructs a component instance of `constructor` with `initialProps` and\n   * renders it into a container node identified by supplied `id`.\n   *\n   * @param {function} componentConstructor React component constructor\n   * @param {?object} props Initial props of the component instance.\n   * @param {string} id ID of the DOM element to render into.\n   * @return {ReactComponent} Component instance rendered in the container node.\n   */\n  constructAndRenderComponentByID: function(constructor, props, id) {\n    var domNode = document.getElementById(id);\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      domNode,\n      'Tried to get element with id of \"%s\" but it is not present on the page.',\n      id\n    ) : invariant(domNode));\n    return ReactMount.constructAndRenderComponent(constructor, props, domNode);\n  },\n\n  /**\n   * Registers a container node into which React components will be rendered.\n   * This also creates the \"reactRoot\" ID that will be assigned to the element\n   * rendered within.\n   *\n   * @param {DOMElement} container DOM element to register as a container.\n   * @return {string} The \"reactRoot\" ID of elements rendered within.\n   */\n  registerContainer: function(container) {\n    var reactRootID = getReactRootID(container);\n    if (reactRootID) {\n      // If one exists, make sure it is a valid \"reactRoot\" ID.\n      reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID);\n    }\n    if (!reactRootID) {\n      // No valid \"reactRoot\" ID found, create one.\n      reactRootID = ReactInstanceHandles.createReactRootID();\n    }\n    containersByReactRootID[reactRootID] = container;\n    return reactRootID;\n  },\n\n  /**\n   * Unmounts and destroys the React component rendered in the `container`.\n   *\n   * @param {DOMElement} container DOM element containing a React component.\n   * @return {boolean} True if a component was found in and unmounted from\n   *                   `container`\n   */\n  unmountComponentAtNode: function(container) {\n    // Various parts of our code (such as ReactCompositeComponent's\n    // _renderValidatedComponent) assume that calls to render aren't nested;\n    // verify that that's the case. (Strictly speaking, unmounting won't cause a\n    // render but we still don't expect to be in a render call here.)\n    (\"production\" !== process.env.NODE_ENV ? warning(\n      ReactCurrentOwner.current == null,\n      'unmountComponentAtNode(): Render methods should be a pure function of ' +\n      'props and state; triggering nested component updates from render is ' +\n      'not allowed. If necessary, trigger nested updates in ' +\n      'componentDidUpdate.'\n    ) : null);\n\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      container && (\n        (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE)\n      ),\n      'unmountComponentAtNode(...): Target container is not a DOM element.'\n    ) : invariant(container && (\n      (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE)\n    )));\n\n    var reactRootID = getReactRootID(container);\n    var component = instancesByReactRootID[reactRootID];\n    if (!component) {\n      return false;\n    }\n    ReactMount.unmountComponentFromNode(component, container);\n    delete instancesByReactRootID[reactRootID];\n    delete containersByReactRootID[reactRootID];\n    if (\"production\" !== process.env.NODE_ENV) {\n      delete rootElementsByReactRootID[reactRootID];\n    }\n    return true;\n  },\n\n  /**\n   * Unmounts a component and removes it from the DOM.\n   *\n   * @param {ReactComponent} instance React component instance.\n   * @param {DOMElement} container DOM element to unmount from.\n   * @final\n   * @internal\n   * @see {ReactMount.unmountComponentAtNode}\n   */\n  unmountComponentFromNode: function(instance, container) {\n    ReactReconciler.unmountComponent(instance);\n\n    if (container.nodeType === DOC_NODE_TYPE) {\n      container = container.documentElement;\n    }\n\n    // http://jsperf.com/emptying-a-node\n    while (container.lastChild) {\n      container.removeChild(container.lastChild);\n    }\n  },\n\n  /**\n   * Finds the container DOM element that contains React component to which the\n   * supplied DOM `id` belongs.\n   *\n   * @param {string} id The ID of an element rendered by a React component.\n   * @return {?DOMElement} DOM element that contains the `id`.\n   */\n  findReactContainerForID: function(id) {\n    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(id);\n    var container = containersByReactRootID[reactRootID];\n\n    if (\"production\" !== process.env.NODE_ENV) {\n      var rootElement = rootElementsByReactRootID[reactRootID];\n      if (rootElement && rootElement.parentNode !== container) {\n        (\"production\" !== process.env.NODE_ENV ? invariant(\n          // Call internalGetID here because getID calls isValid which calls\n          // findReactContainerForID (this function).\n          internalGetID(rootElement) === reactRootID,\n          'ReactMount: Root element ID differed from reactRootID.'\n        ) : invariant(// Call internalGetID here because getID calls isValid which calls\n        // findReactContainerForID (this function).\n        internalGetID(rootElement) === reactRootID));\n\n        var containerChild = container.firstChild;\n        if (containerChild &&\n            reactRootID === internalGetID(containerChild)) {\n          // If the container has a new child with the same ID as the old\n          // root element, then rootElementsByReactRootID[reactRootID] is\n          // just stale and needs to be updated. The case that deserves a\n          // warning is when the container is empty.\n          rootElementsByReactRootID[reactRootID] = containerChild;\n        } else {\n          (\"production\" !== process.env.NODE_ENV ? warning(\n            false,\n            'ReactMount: Root element has been removed from its original ' +\n            'container. New container:', rootElement.parentNode\n          ) : null);\n        }\n      }\n    }\n\n    return container;\n  },\n\n  /**\n   * Finds an element rendered by React with the supplied ID.\n   *\n   * @param {string} id ID of a DOM node in the React component.\n   * @return {DOMElement} Root DOM node of the React component.\n   */\n  findReactNodeByID: function(id) {\n    var reactRoot = ReactMount.findReactContainerForID(id);\n    return ReactMount.findComponentRoot(reactRoot, id);\n  },\n\n  /**\n   * True if the supplied `node` is rendered by React.\n   *\n   * @param {*} node DOM Element to check.\n   * @return {boolean} True if the DOM Element appears to be rendered by React.\n   * @internal\n   */\n  isRenderedByReact: function(node) {\n    if (node.nodeType !== 1) {\n      // Not a DOMElement, therefore not a React component\n      return false;\n    }\n    var id = ReactMount.getID(node);\n    return id ? id.charAt(0) === SEPARATOR : false;\n  },\n\n  /**\n   * Traverses up the ancestors of the supplied node to find a node that is a\n   * DOM representation of a React component.\n   *\n   * @param {*} node\n   * @return {?DOMEventTarget}\n   * @internal\n   */\n  getFirstReactDOM: function(node) {\n    var current = node;\n    while (current && current.parentNode !== current) {\n      if (ReactMount.isRenderedByReact(current)) {\n        return current;\n      }\n      current = current.parentNode;\n    }\n    return null;\n  },\n\n  /**\n   * Finds a node with the supplied `targetID` inside of the supplied\n   * `ancestorNode`.  Exploits the ID naming scheme to perform the search\n   * quickly.\n   *\n   * @param {DOMEventTarget} ancestorNode Search from this root.\n   * @pararm {string} targetID ID of the DOM representation of the component.\n   * @return {DOMEventTarget} DOM node with the supplied `targetID`.\n   * @internal\n   */\n  findComponentRoot: function(ancestorNode, targetID) {\n    var firstChildren = findComponentRootReusableArray;\n    var childIndex = 0;\n\n    var deepestAncestor = findDeepestCachedAncestor(targetID) || ancestorNode;\n\n    firstChildren[0] = deepestAncestor.firstChild;\n    firstChildren.length = 1;\n\n    while (childIndex < firstChildren.length) {\n      var child = firstChildren[childIndex++];\n      var targetChild;\n\n      while (child) {\n        var childID = ReactMount.getID(child);\n        if (childID) {\n          // Even if we find the node we're looking for, we finish looping\n          // through its siblings to ensure they're cached so that we don't have\n          // to revisit this node again. Otherwise, we make n^2 calls to getID\n          // when visiting the many children of a single node in order.\n\n          if (targetID === childID) {\n            targetChild = child;\n          } else if (ReactInstanceHandles.isAncestorIDOf(childID, targetID)) {\n            // If we find a child whose ID is an ancestor of the given ID,\n            // then we can be sure that we only want to search the subtree\n            // rooted at this child, so we can throw out the rest of the\n            // search state.\n            firstChildren.length = childIndex = 0;\n            firstChildren.push(child.firstChild);\n          }\n\n        } else {\n          // If this child had no ID, then there's a chance that it was\n          // injected automatically by the browser, as when a `<table>`\n          // element sprouts an extra `<tbody>` child as a side effect of\n          // `.innerHTML` parsing. Optimistically continue down this\n          // branch, but not before examining the other siblings.\n          firstChildren.push(child.firstChild);\n        }\n\n        child = child.nextSibling;\n      }\n\n      if (targetChild) {\n        // Emptying firstChildren/findComponentRootReusableArray is\n        // not necessary for correctness, but it helps the GC reclaim\n        // any nodes that were left at the end of the search.\n        firstChildren.length = 0;\n\n        return targetChild;\n      }\n    }\n\n    firstChildren.length = 0;\n\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      false,\n      'findComponentRoot(..., %s): Unable to find element. This probably ' +\n      'means the DOM was unexpectedly mutated (e.g., by the browser), ' +\n      'usually due to forgetting a <tbody> when using tables, nesting tags ' +\n      'like <form>, <p>, or <a>, or using non-SVG elements in an <svg> ' +\n      'parent. ' +\n      'Try inspecting the child nodes of the element with React ID `%s`.',\n      targetID,\n      ReactMount.getID(ancestorNode)\n    ) : invariant(false));\n  },\n\n  _mountImageIntoNode: function(markup, container, shouldReuseMarkup) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      container && (\n        (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE)\n      ),\n      'mountComponentIntoNode(...): Target container is not valid.'\n    ) : invariant(container && (\n      (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE)\n    )));\n\n    if (shouldReuseMarkup) {\n      var rootElement = getReactRootElementInContainer(container);\n      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {\n        return;\n      } else {\n        var checksum = rootElement.getAttribute(\n          ReactMarkupChecksum.CHECKSUM_ATTR_NAME\n        );\n        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);\n\n        var rootMarkup = rootElement.outerHTML;\n        rootElement.setAttribute(\n          ReactMarkupChecksum.CHECKSUM_ATTR_NAME,\n          checksum\n        );\n\n        var diffIndex = firstDifferenceIndex(markup, rootMarkup);\n        var difference = ' (client) ' +\n          markup.substring(diffIndex - 20, diffIndex + 20) +\n          '\\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);\n\n        (\"production\" !== process.env.NODE_ENV ? invariant(\n          container.nodeType !== DOC_NODE_TYPE,\n          'You\\'re trying to render a component to the document using ' +\n          'server rendering but the checksum was invalid. This usually ' +\n          'means you rendered a different component type or props on ' +\n          'the client from the one on the server, or your render() ' +\n          'methods are impure. React cannot handle this case due to ' +\n          'cross-browser quirks by rendering at the document root. You ' +\n          'should look for environment dependent code in your components ' +\n          'and ensure the props are the same client and server side:\\n%s',\n          difference\n        ) : invariant(container.nodeType !== DOC_NODE_TYPE));\n\n        if (\"production\" !== process.env.NODE_ENV) {\n          (\"production\" !== process.env.NODE_ENV ? warning(\n            false,\n            'React attempted to reuse markup in a container but the ' +\n            'checksum was invalid. This generally means that you are ' +\n            'using server rendering and the markup generated on the ' +\n            'server was not what the client was expecting. React injected ' +\n            'new markup to compensate which works but you have lost many ' +\n            'of the benefits of server rendering. Instead, figure out ' +\n            'why the markup being generated is different on the client ' +\n            'or server:\\n%s',\n            difference\n          ) : null);\n        }\n      }\n    }\n\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      container.nodeType !== DOC_NODE_TYPE,\n      'You\\'re trying to render a component to the document but ' +\n        'you didn\\'t use server rendering. We can\\'t do this ' +\n        'without using server rendering due to cross-browser quirks. ' +\n        'See React.renderToString() for server rendering.'\n    ) : invariant(container.nodeType !== DOC_NODE_TYPE));\n\n    setInnerHTML(container, markup);\n  },\n\n  /**\n   * React ID utilities.\n   */\n\n  getReactRootID: getReactRootID,\n\n  getID: getID,\n\n  setID: setID,\n\n  getNode: getNode,\n\n  getNodeFromInstance: getNodeFromInstance,\n\n  purgeID: purgeID\n};\n\nReactPerf.measureMethods(ReactMount, 'ReactMount', {\n  _renderNewRootComponent: '_renderNewRootComponent',\n  _mountImageIntoNode: '_mountImageIntoNode'\n});\n\nmodule.exports = ReactMount;\n"]},"metadata":{},"sourceType":"script"}