{"ast":null,"code":"'use strict';\n\nconst fs = require('fs');\n\nconst path = require('path');\n\nconst {\n  Readable\n} = require('stream'); // Parameters for safe file name parsing.\n\n\nconst SAFE_FILE_NAME_REGEX = /[^\\w-]/g;\nconst MAX_EXTENSION_LENGTH = 3; // Parameters to generate unique temporary file names:\n\nconst TEMP_COUNTER_MAX = 65536;\nconst TEMP_PREFIX = 'tmp';\nlet tempCounter = 0;\n/**\r\n * Logs message to console if debug option set to true.\r\n * @param {Object} options - options object.\r\n * @param {string} msg - message to log.\r\n * @returns {boolean} - false if debug is off.\r\n */\n\nconst debugLog = (options, msg) => {\n  const opts = options || {};\n  if (!opts.debug) return false;\n  console.log(`Express-file-upload: ${msg}`); // eslint-disable-line\n\n  return true;\n};\n/**\r\n * Generates unique temporary file name. e.g. tmp-5000-156788789789.\r\n * @param {string} prefix - a prefix for generated unique file name.\r\n * @returns {string}\r\n */\n\n\nconst getTempFilename = (prefix = TEMP_PREFIX) => {\n  tempCounter = tempCounter >= TEMP_COUNTER_MAX ? 1 : tempCounter + 1;\n  return `${prefix}-${tempCounter}-${Date.now()}`;\n};\n/**\r\n * isFunc: Checks if argument is a function.\r\n * @returns {boolean} - Returns true if argument is a function.\r\n */\n\n\nconst isFunc = func => func && func.constructor && func.call && func.apply ? true : false;\n/**\r\n * Set errorFunc to the same value as successFunc for callback mode.\r\n * @returns {Function}\r\n */\n\n\nconst errorFunc = (resolve, reject) => isFunc(reject) ? reject : resolve;\n/**\r\n * Return a callback function for promise resole/reject args.\r\n * @returns {Function}\r\n */\n\n\nconst promiseCallback = (resolve, reject) => {\n  return err => err ? errorFunc(resolve, reject)(err) : resolve();\n};\n/**\r\n * Builds instance options from arguments objects(can't be arrow function).\r\n * @returns {Object} - result options.\r\n */\n\n\nconst buildOptions = function () {\n  const result = {};\n  [...arguments].forEach(options => {\n    if (!options || typeof options !== 'object') return;\n    Object.keys(options).forEach(i => result[i] = options[i]);\n  });\n  return result;\n};\n/**\r\n * Builds request fields (using to build req.body and req.files)\r\n * @param {Object} instance - request object.\r\n * @param {string} field - field name.\r\n * @param {any} value - field value.\r\n * @returns {Object}\r\n */\n\n\nconst buildFields = (instance, field, value) => {\n  // Do nothing if value is not set.\n  if (value === null || value === undefined) return instance;\n  instance = instance || {}; // Non-array fields\n\n  if (!instance[field]) {\n    instance[field] = value;\n    return instance;\n  } // Array fields  \n\n\n  if (instance[field] instanceof Array) {\n    instance[field].push(value);\n  } else {\n    instance[field] = [instance[field], value];\n  }\n\n  return instance;\n};\n/**\r\n * Creates a folder for file specified in the path variable\r\n * @param {Object} fileUploadOptions\r\n * @param {string} filePath\r\n * @returns {boolean}\r\n */\n\n\nconst checkAndMakeDir = (fileUploadOptions, filePath) => {\n  // Check upload options were set.\n  if (!fileUploadOptions) return false;\n  if (!fileUploadOptions.createParentPath) return false; // Check whether folder for the file exists.\n\n  if (!filePath) return false;\n  const parentPath = path.dirname(filePath); // Create folder if it doesn't exist.\n\n  if (!fs.existsSync(parentPath)) fs.mkdirSync(parentPath, {\n    recursive: true\n  }); // Checks folder again and return a results.\n\n  return fs.existsSync(parentPath);\n};\n/**\r\n * Deletes a file.\r\n * @param {string} file - Path to the file to delete.\r\n * @param {Function} callback\r\n */\n\n\nconst deleteFile = (file, callback) => fs.unlink(file, callback);\n/**\r\n * Copy file via streams\r\n * @param {string} src - Path to the source file\r\n * @param {string} dst - Path to the destination file.\r\n */\n\n\nconst copyFile = (src, dst, callback) => {\n  // cbCalled flag and runCb helps to run cb only once.\n  let cbCalled = false;\n\n  let runCb = err => {\n    if (cbCalled) return;\n    cbCalled = true;\n    callback(err);\n  }; // Create read stream\n\n\n  let readable = fs.createReadStream(src);\n  readable.on('error', runCb); // Create write stream\n\n  let writable = fs.createWriteStream(dst);\n  writable.on('error', err => {\n    readable.destroy();\n    runCb(err);\n  });\n  writable.on('close', () => runCb()); // Copy file via piping streams.\n\n  readable.pipe(writable);\n};\n/**\r\n * moveFile: moves the file from src to dst.\r\n * Firstly trying to rename the file if no luck copying it to dst and then deleteing src.\r\n * @param {string} src - Path to the source file\r\n * @param {string} dst - Path to the destination file.\r\n * @param {Function} callback - A callback function.\r\n */\n\n\nconst moveFile = (src, dst, callback) => fs.rename(src, dst, err => err ? copyFile(src, dst, err => err ? callback(err) : deleteFile(src, callback)) : callback());\n/**\r\n * Save buffer data to a file.\r\n * @param {Buffer} buffer - buffer to save to a file.\r\n * @param {string} filePath - path to a file.\r\n */\n\n\nconst saveBufferToFile = (buffer, filePath, callback) => {\n  if (!Buffer.isBuffer(buffer)) {\n    return callback(new Error('buffer variable should be type of Buffer!'));\n  } // Setup readable stream from buffer.\n\n\n  let streamData = buffer;\n  let readStream = Readable();\n\n  readStream._read = () => {\n    readStream.push(streamData);\n    streamData = null;\n  }; // Setup file system writable stream.\n\n\n  let fstream = fs.createWriteStream(filePath);\n  fstream.on('error', err => callback(err));\n  fstream.on('close', () => callback()); // Copy file via piping streams.\n\n  readStream.pipe(fstream);\n};\n/**\r\n * Decodes uriEncoded file names.\r\n * @param fileName {String} - file name to decode.\r\n * @returns {String}\r\n */\n\n\nconst uriDecodeFileName = (opts, fileName) => {\n  return opts.uriDecodeFileNames ? decodeURIComponent(fileName) : fileName;\n};\n/**\r\n * Parses filename and extension and returns object {name, extension}.\r\n * @param {boolean|integer} preserveExtension - true/false or number of characters for extension.\r\n * @param {string} fileName - file name to parse.\r\n * @returns {Object} - { name, extension }.\r\n */\n\n\nconst parseFileNameExtension = (preserveExtension, fileName) => {\n  const preserveExtensionLengh = parseInt(preserveExtension);\n  const result = {\n    name: fileName,\n    extension: ''\n  };\n  if (!preserveExtension && preserveExtensionLengh !== 0) return result; // Define maximum extension length\n\n  const maxExtLength = isNaN(preserveExtensionLengh) ? MAX_EXTENSION_LENGTH : Math.abs(preserveExtensionLengh);\n  const nameParts = fileName.split('.');\n  if (nameParts.length < 2) return result;\n  let extension = nameParts.pop();\n\n  if (extension.length > maxExtLength && maxExtLength > 0) {\n    nameParts[nameParts.length - 1] += '.' + extension.substr(0, extension.length - maxExtLength);\n    extension = extension.substr(-maxExtLength);\n  }\n\n  result.extension = maxExtLength ? extension : '';\n  result.name = nameParts.join('.');\n  return result;\n};\n/**\r\n * Parse file name and extension.\r\n * @param {Object} opts - middleware options.\r\n * @param {string} fileName - Uploaded file name.\r\n * @returns {string}\r\n */\n\n\nconst parseFileName = (opts, fileName) => {\n  // Check fileName argument\n  if (!fileName || typeof fileName !== 'string') return getTempFilename(); // Cut off file name if it's lenght more then 255.\n\n  let parsedName = fileName.length <= 255 ? fileName : fileName.substr(0, 255); // Decode file name if uriDecodeFileNames option set true.\n\n  parsedName = uriDecodeFileName(opts, parsedName); // Stop parsing file name if safeFileNames options hasn't been set.\n\n  if (!opts.safeFileNames) return parsedName; // Set regular expression for the file name.\n\n  const nameRegex = typeof opts.safeFileNames === 'object' && opts.safeFileNames instanceof RegExp ? opts.safeFileNames : SAFE_FILE_NAME_REGEX; // Parse file name extension.\n\n  let {\n    name,\n    extension\n  } = parseFileNameExtension(opts.preserveExtension, parsedName);\n  if (extension.length) extension = '.' + extension.replace(nameRegex, '');\n  return name.replace(nameRegex, '').concat(extension);\n};\n\nmodule.exports = {\n  isFunc,\n  debugLog,\n  copyFile,\n  // For testing purpose.\n  moveFile,\n  errorFunc,\n  deleteFile,\n  // For testing purpose.\n  buildFields,\n  buildOptions,\n  parseFileName,\n  getTempFilename,\n  promiseCallback,\n  checkAndMakeDir,\n  saveBufferToFile,\n  uriDecodeFileName\n};","map":{"version":3,"sources":["C:/Users/apollo/IPS/node_modules/express-fileupload/lib/utilities.js"],"names":["fs","require","path","Readable","SAFE_FILE_NAME_REGEX","MAX_EXTENSION_LENGTH","TEMP_COUNTER_MAX","TEMP_PREFIX","tempCounter","debugLog","options","msg","opts","debug","console","log","getTempFilename","prefix","Date","now","isFunc","func","constructor","call","apply","errorFunc","resolve","reject","promiseCallback","err","buildOptions","result","arguments","forEach","Object","keys","i","buildFields","instance","field","value","undefined","Array","push","checkAndMakeDir","fileUploadOptions","filePath","createParentPath","parentPath","dirname","existsSync","mkdirSync","recursive","deleteFile","file","callback","unlink","copyFile","src","dst","cbCalled","runCb","readable","createReadStream","on","writable","createWriteStream","destroy","pipe","moveFile","rename","saveBufferToFile","buffer","Buffer","isBuffer","Error","streamData","readStream","_read","fstream","uriDecodeFileName","fileName","uriDecodeFileNames","decodeURIComponent","parseFileNameExtension","preserveExtension","preserveExtensionLengh","parseInt","name","extension","maxExtLength","isNaN","Math","abs","nameParts","split","length","pop","substr","join","parseFileName","parsedName","safeFileNames","nameRegex","RegExp","replace","concat","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nconst fs = require('fs');\r\nconst path = require('path');\r\nconst { Readable } = require('stream');\r\n\r\n// Parameters for safe file name parsing.\r\nconst SAFE_FILE_NAME_REGEX = /[^\\w-]/g;\r\nconst MAX_EXTENSION_LENGTH = 3;\r\n\r\n// Parameters to generate unique temporary file names:\r\nconst TEMP_COUNTER_MAX = 65536;\r\nconst TEMP_PREFIX = 'tmp';\r\nlet tempCounter = 0;\r\n\r\n/**\r\n * Logs message to console if debug option set to true.\r\n * @param {Object} options - options object.\r\n * @param {string} msg - message to log.\r\n * @returns {boolean} - false if debug is off.\r\n */\r\nconst debugLog = (options, msg) => {\r\n  const opts = options || {};\r\n  if (!opts.debug) return false;\r\n  console.log(`Express-file-upload: ${msg}`); // eslint-disable-line\r\n  return true;\r\n};\r\n\r\n/**\r\n * Generates unique temporary file name. e.g. tmp-5000-156788789789.\r\n * @param {string} prefix - a prefix for generated unique file name.\r\n * @returns {string}\r\n */\r\nconst getTempFilename = (prefix = TEMP_PREFIX) => {\r\n  tempCounter = tempCounter >= TEMP_COUNTER_MAX ? 1 : tempCounter + 1;\r\n  return `${prefix}-${tempCounter}-${Date.now()}`;\r\n};\r\n\r\n/**\r\n * isFunc: Checks if argument is a function.\r\n * @returns {boolean} - Returns true if argument is a function.\r\n */\r\nconst isFunc = func => func && func.constructor && func.call && func.apply ? true: false;\r\n\r\n/**\r\n * Set errorFunc to the same value as successFunc for callback mode.\r\n * @returns {Function}\r\n */\r\nconst errorFunc = (resolve, reject) => isFunc(reject) ? reject : resolve;\r\n\r\n/**\r\n * Return a callback function for promise resole/reject args.\r\n * @returns {Function}\r\n */\r\nconst promiseCallback = (resolve, reject) => {\r\n  return err => err ? errorFunc(resolve, reject)(err) : resolve();\r\n};\r\n\r\n/**\r\n * Builds instance options from arguments objects(can't be arrow function).\r\n * @returns {Object} - result options.\r\n */\r\nconst buildOptions = function() {\r\n  const result = {};\r\n  [...arguments].forEach(options => {\r\n    if (!options || typeof options !== 'object') return;\r\n    Object.keys(options).forEach(i => result[i] = options[i]);\r\n  });\r\n  return result;\r\n};\r\n\r\n/**\r\n * Builds request fields (using to build req.body and req.files)\r\n * @param {Object} instance - request object.\r\n * @param {string} field - field name.\r\n * @param {any} value - field value.\r\n * @returns {Object}\r\n */\r\nconst buildFields = (instance, field, value) => {\r\n  // Do nothing if value is not set.\r\n  if (value === null || value === undefined) return instance;\r\n  instance = instance || {};\r\n  // Non-array fields\r\n  if (!instance[field]) {\r\n    instance[field] = value;\r\n    return instance;\r\n  }\r\n  // Array fields  \r\n  if (instance[field] instanceof Array) {\r\n    instance[field].push(value);\r\n  } else {\r\n    instance[field] = [instance[field], value];\r\n  }\r\n  return instance;\r\n};\r\n\r\n/**\r\n * Creates a folder for file specified in the path variable\r\n * @param {Object} fileUploadOptions\r\n * @param {string} filePath\r\n * @returns {boolean}\r\n */\r\nconst checkAndMakeDir = (fileUploadOptions, filePath) => {\r\n  // Check upload options were set.\r\n  if (!fileUploadOptions) return false;\r\n  if (!fileUploadOptions.createParentPath) return false;\r\n  // Check whether folder for the file exists.\r\n  if (!filePath) return false;\r\n  const parentPath = path.dirname(filePath);\r\n  // Create folder if it doesn't exist.\r\n  if (!fs.existsSync(parentPath)) fs.mkdirSync(parentPath, { recursive: true }); \r\n  // Checks folder again and return a results.\r\n  return fs.existsSync(parentPath);\r\n};\r\n\r\n/**\r\n * Deletes a file.\r\n * @param {string} file - Path to the file to delete.\r\n * @param {Function} callback\r\n */\r\nconst deleteFile = (file, callback) => fs.unlink(file, callback);\r\n\r\n/**\r\n * Copy file via streams\r\n * @param {string} src - Path to the source file\r\n * @param {string} dst - Path to the destination file.\r\n */\r\nconst copyFile = (src, dst, callback) => {\r\n  // cbCalled flag and runCb helps to run cb only once.\r\n  let cbCalled = false;\r\n  let runCb = (err) => {\r\n    if (cbCalled) return;\r\n    cbCalled = true;\r\n    callback(err);\r\n  };\r\n  // Create read stream\r\n  let readable = fs.createReadStream(src);\r\n  readable.on('error', runCb);\r\n  // Create write stream\r\n  let writable = fs.createWriteStream(dst);\r\n  writable.on('error', (err)=>{\r\n    readable.destroy();\r\n    runCb(err);\r\n  });\r\n  writable.on('close', () => runCb());\r\n  // Copy file via piping streams.\r\n  readable.pipe(writable);\r\n};\r\n\r\n/**\r\n * moveFile: moves the file from src to dst.\r\n * Firstly trying to rename the file if no luck copying it to dst and then deleteing src.\r\n * @param {string} src - Path to the source file\r\n * @param {string} dst - Path to the destination file.\r\n * @param {Function} callback - A callback function.\r\n */\r\nconst moveFile = (src, dst, callback) => fs.rename(src, dst, err => (err\r\n  ? copyFile(src, dst, err => err ? callback(err) : deleteFile(src, callback))\r\n  : callback()\r\n));\r\n\r\n/**\r\n * Save buffer data to a file.\r\n * @param {Buffer} buffer - buffer to save to a file.\r\n * @param {string} filePath - path to a file.\r\n */\r\nconst saveBufferToFile = (buffer, filePath, callback) => {\r\n  if (!Buffer.isBuffer(buffer)) {\r\n    return callback(new Error('buffer variable should be type of Buffer!'));\r\n  }\r\n  // Setup readable stream from buffer.\r\n  let streamData = buffer;\r\n  let readStream = Readable();\r\n  readStream._read = () => {\r\n    readStream.push(streamData);\r\n    streamData = null;\r\n  };\r\n  // Setup file system writable stream.\r\n  let fstream = fs.createWriteStream(filePath);\r\n  fstream.on('error', err => callback(err));\r\n  fstream.on('close', () => callback());\r\n  // Copy file via piping streams.\r\n  readStream.pipe(fstream);\r\n};\r\n\r\n/**\r\n * Decodes uriEncoded file names.\r\n * @param fileName {String} - file name to decode.\r\n * @returns {String}\r\n */\r\nconst uriDecodeFileName = (opts, fileName) => {\r\n  return opts.uriDecodeFileNames ? decodeURIComponent(fileName) : fileName;\r\n};\r\n\r\n/**\r\n * Parses filename and extension and returns object {name, extension}.\r\n * @param {boolean|integer} preserveExtension - true/false or number of characters for extension.\r\n * @param {string} fileName - file name to parse.\r\n * @returns {Object} - { name, extension }.\r\n */\r\nconst parseFileNameExtension = (preserveExtension, fileName) => {\r\n  const preserveExtensionLengh = parseInt(preserveExtension);\r\n  const result = {name: fileName, extension: ''};\r\n  if (!preserveExtension && preserveExtensionLengh !== 0) return result;\r\n  // Define maximum extension length\r\n  const maxExtLength = isNaN(preserveExtensionLengh)\r\n    ? MAX_EXTENSION_LENGTH\r\n    : Math.abs(preserveExtensionLengh);\r\n\r\n  const nameParts = fileName.split('.');\r\n  if (nameParts.length < 2) return result;\r\n  \r\n  let extension = nameParts.pop();\r\n  if (\r\n    extension.length > maxExtLength &&\r\n    maxExtLength > 0\r\n  ) {\r\n    nameParts[nameParts.length - 1] +=\r\n      '.' +\r\n      extension.substr(0, extension.length - maxExtLength);\r\n    extension = extension.substr(-maxExtLength);\r\n  }\r\n\r\n  result.extension = maxExtLength ? extension : '';\r\n  result.name = nameParts.join('.');\r\n  return result;\r\n};\r\n\r\n/**\r\n * Parse file name and extension.\r\n * @param {Object} opts - middleware options.\r\n * @param {string} fileName - Uploaded file name.\r\n * @returns {string}\r\n */\r\nconst parseFileName = (opts, fileName) => {\r\n  // Check fileName argument\r\n  if (!fileName || typeof fileName !== 'string') return getTempFilename();\r\n  // Cut off file name if it's lenght more then 255.\r\n  let parsedName = fileName.length <= 255 ? fileName : fileName.substr(0, 255);\r\n  // Decode file name if uriDecodeFileNames option set true.\r\n  parsedName = uriDecodeFileName(opts, parsedName);\r\n  // Stop parsing file name if safeFileNames options hasn't been set.\r\n  if (!opts.safeFileNames) return parsedName;\r\n  // Set regular expression for the file name.\r\n  const nameRegex = typeof opts.safeFileNames === 'object' && opts.safeFileNames instanceof RegExp\r\n    ? opts.safeFileNames\r\n    : SAFE_FILE_NAME_REGEX;\r\n  // Parse file name extension.\r\n  let {name, extension} = parseFileNameExtension(opts.preserveExtension, parsedName);\r\n  if (extension.length) extension = '.' + extension.replace(nameRegex, '');\r\n\r\n  return name.replace(nameRegex, '').concat(extension);\r\n};\r\n\r\nmodule.exports = {\r\n  isFunc,\r\n  debugLog,\r\n  copyFile, // For testing purpose.\r\n  moveFile,\r\n  errorFunc,\r\n  deleteFile, // For testing purpose.\r\n  buildFields,\r\n  buildOptions,\r\n  parseFileName,\r\n  getTempFilename,\r\n  promiseCallback,\r\n  checkAndMakeDir,\r\n  saveBufferToFile,\r\n  uriDecodeFileName\r\n};\r\n"]},"metadata":{},"sourceType":"script"}