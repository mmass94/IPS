{"ast":null,"code":"/**\n * Copyright 2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n* @providesModule ReactFragment\n*/\n'use strict';\n\nvar ReactElement = require(\"./ReactElement\");\n\nvar warning = require(\"./warning\");\n/**\n * We used to allow keyed objects to serve as a collection of ReactElements,\n * or nested sets. This allowed us a way to explicitly key a set a fragment of\n * components. This is now being replaced with an opaque data structure.\n * The upgrade path is to call React.addons.createFragment({ key: value }) to\n * create a keyed fragment. The resulting data structure is opaque, for now.\n */\n\n\nif (\"production\" !== process.env.NODE_ENV) {\n  var fragmentKey = '_reactFragment';\n  var didWarnKey = '_reactDidWarn';\n  var canWarnForReactFragment = false;\n\n  try {\n    // Feature test. Don't even try to issue this warning if we can't use\n    // enumerable: false.\n    var dummy = function () {\n      return 1;\n    };\n\n    Object.defineProperty({}, fragmentKey, {\n      enumerable: false,\n      value: true\n    });\n    Object.defineProperty({}, 'key', {\n      enumerable: true,\n      get: dummy\n    });\n    canWarnForReactFragment = true;\n  } catch (x) {}\n\n  var proxyPropertyAccessWithWarning = function (obj, key) {\n    Object.defineProperty(obj, key, {\n      enumerable: true,\n      get: function () {\n        \"production\" !== process.env.NODE_ENV ? warning(this[didWarnKey], 'A ReactFragment is an opaque type. Accessing any of its ' + 'properties is deprecated. Pass it to one of the React.Children ' + 'helpers.') : null;\n        this[didWarnKey] = true;\n        return this[fragmentKey][key];\n      },\n      set: function (value) {\n        \"production\" !== process.env.NODE_ENV ? warning(this[didWarnKey], 'A ReactFragment is an immutable opaque type. Mutating its ' + 'properties is deprecated.') : null;\n        this[didWarnKey] = true;\n        this[fragmentKey][key] = value;\n      }\n    });\n  };\n\n  var issuedWarnings = {};\n\n  var didWarnForFragment = function (fragment) {\n    // We use the keys and the type of the value as a heuristic to dedupe the\n    // warning to avoid spamming too much.\n    var fragmentCacheKey = '';\n\n    for (var key in fragment) {\n      fragmentCacheKey += key + ':' + typeof fragment[key] + ',';\n    }\n\n    var alreadyWarnedOnce = !!issuedWarnings[fragmentCacheKey];\n    issuedWarnings[fragmentCacheKey] = true;\n    return alreadyWarnedOnce;\n  };\n}\n\nvar ReactFragment = {\n  // Wrap a keyed object in an opaque proxy that warns you if you access any\n  // of its properties.\n  create: function (object) {\n    if (\"production\" !== process.env.NODE_ENV) {\n      if (typeof object !== 'object' || !object || Array.isArray(object)) {\n        \"production\" !== process.env.NODE_ENV ? warning(false, 'React.addons.createFragment only accepts a single object.', object) : null;\n        return object;\n      }\n\n      if (ReactElement.isValidElement(object)) {\n        \"production\" !== process.env.NODE_ENV ? warning(false, 'React.addons.createFragment does not accept a ReactElement ' + 'without a wrapper object.') : null;\n        return object;\n      }\n\n      if (canWarnForReactFragment) {\n        var proxy = {};\n        Object.defineProperty(proxy, fragmentKey, {\n          enumerable: false,\n          value: object\n        });\n        Object.defineProperty(proxy, didWarnKey, {\n          writable: true,\n          enumerable: false,\n          value: false\n        });\n\n        for (var key in object) {\n          proxyPropertyAccessWithWarning(proxy, key);\n        }\n\n        Object.preventExtensions(proxy);\n        return proxy;\n      }\n    }\n\n    return object;\n  },\n  // Extract the original keyed object from the fragment opaque type. Warn if\n  // a plain object is passed here.\n  extract: function (fragment) {\n    if (\"production\" !== process.env.NODE_ENV) {\n      if (canWarnForReactFragment) {\n        if (!fragment[fragmentKey]) {\n          \"production\" !== process.env.NODE_ENV ? warning(didWarnForFragment(fragment), 'Any use of a keyed object should be wrapped in ' + 'React.addons.createFragment(object) before being passed as a ' + 'child.') : null;\n          return fragment;\n        }\n\n        return fragment[fragmentKey];\n      }\n    }\n\n    return fragment;\n  },\n  // Check if this is a fragment and if so, extract the keyed object. If it\n  // is a fragment-like object, warn that it should be wrapped. Ignore if we\n  // can't determine what kind of object this is.\n  extractIfFragment: function (fragment) {\n    if (\"production\" !== process.env.NODE_ENV) {\n      if (canWarnForReactFragment) {\n        // If it is the opaque type, return the keyed object.\n        if (fragment[fragmentKey]) {\n          return fragment[fragmentKey];\n        } // Otherwise, check each property if it has an element, if it does\n        // it is probably meant as a fragment, so we can warn early. Defer,\n        // the warning to extract.\n\n\n        for (var key in fragment) {\n          if (fragment.hasOwnProperty(key) && ReactElement.isValidElement(fragment[key])) {\n            // This looks like a fragment object, we should provide an\n            // early warning.\n            return ReactFragment.extract(fragment);\n          }\n        }\n      }\n    }\n\n    return fragment;\n  }\n};\nmodule.exports = ReactFragment;","map":{"version":3,"sources":["C:/Users/apollo/islamicpsychologyapi/node_modules/react/lib/ReactFragment.js"],"names":["ReactElement","require","warning","process","env","NODE_ENV","fragmentKey","didWarnKey","canWarnForReactFragment","dummy","Object","defineProperty","enumerable","value","get","x","proxyPropertyAccessWithWarning","obj","key","set","issuedWarnings","didWarnForFragment","fragment","fragmentCacheKey","alreadyWarnedOnce","ReactFragment","create","object","Array","isArray","isValidElement","proxy","writable","preventExtensions","extract","extractIfFragment","hasOwnProperty","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright 2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n* @providesModule ReactFragment\n*/\n\n'use strict';\n\nvar ReactElement = require(\"./ReactElement\");\n\nvar warning = require(\"./warning\");\n\n/**\n * We used to allow keyed objects to serve as a collection of ReactElements,\n * or nested sets. This allowed us a way to explicitly key a set a fragment of\n * components. This is now being replaced with an opaque data structure.\n * The upgrade path is to call React.addons.createFragment({ key: value }) to\n * create a keyed fragment. The resulting data structure is opaque, for now.\n */\n\nif (\"production\" !== process.env.NODE_ENV) {\n  var fragmentKey = '_reactFragment';\n  var didWarnKey = '_reactDidWarn';\n  var canWarnForReactFragment = false;\n\n  try {\n    // Feature test. Don't even try to issue this warning if we can't use\n    // enumerable: false.\n\n    var dummy = function() {\n      return 1;\n    };\n\n    Object.defineProperty(\n      {},\n      fragmentKey,\n      {enumerable: false, value: true}\n    );\n\n    Object.defineProperty(\n      {},\n      'key',\n      {enumerable: true, get: dummy}\n    );\n\n    canWarnForReactFragment = true;\n  } catch (x) { }\n\n  var proxyPropertyAccessWithWarning = function(obj, key) {\n    Object.defineProperty(obj, key, {\n      enumerable: true,\n      get: function() {\n        (\"production\" !== process.env.NODE_ENV ? warning(\n          this[didWarnKey],\n          'A ReactFragment is an opaque type. Accessing any of its ' +\n          'properties is deprecated. Pass it to one of the React.Children ' +\n          'helpers.'\n        ) : null);\n        this[didWarnKey] = true;\n        return this[fragmentKey][key];\n      },\n      set: function(value) {\n        (\"production\" !== process.env.NODE_ENV ? warning(\n          this[didWarnKey],\n          'A ReactFragment is an immutable opaque type. Mutating its ' +\n          'properties is deprecated.'\n        ) : null);\n        this[didWarnKey] = true;\n        this[fragmentKey][key] = value;\n      }\n    });\n  };\n\n  var issuedWarnings = {};\n\n  var didWarnForFragment = function(fragment) {\n    // We use the keys and the type of the value as a heuristic to dedupe the\n    // warning to avoid spamming too much.\n    var fragmentCacheKey = '';\n    for (var key in fragment) {\n      fragmentCacheKey += key + ':' + (typeof fragment[key]) + ',';\n    }\n    var alreadyWarnedOnce = !!issuedWarnings[fragmentCacheKey];\n    issuedWarnings[fragmentCacheKey] = true;\n    return alreadyWarnedOnce;\n  };\n}\n\nvar ReactFragment = {\n  // Wrap a keyed object in an opaque proxy that warns you if you access any\n  // of its properties.\n  create: function(object) {\n    if (\"production\" !== process.env.NODE_ENV) {\n      if (typeof object !== 'object' || !object || Array.isArray(object)) {\n        (\"production\" !== process.env.NODE_ENV ? warning(\n          false,\n          'React.addons.createFragment only accepts a single object.',\n          object\n        ) : null);\n        return object;\n      }\n      if (ReactElement.isValidElement(object)) {\n        (\"production\" !== process.env.NODE_ENV ? warning(\n          false,\n          'React.addons.createFragment does not accept a ReactElement ' +\n          'without a wrapper object.'\n        ) : null);\n        return object;\n      }\n      if (canWarnForReactFragment) {\n        var proxy = {};\n        Object.defineProperty(proxy, fragmentKey, {\n          enumerable: false,\n          value: object\n        });\n        Object.defineProperty(proxy, didWarnKey, {\n          writable: true,\n          enumerable: false,\n          value: false\n        });\n        for (var key in object) {\n          proxyPropertyAccessWithWarning(proxy, key);\n        }\n        Object.preventExtensions(proxy);\n        return proxy;\n      }\n    }\n    return object;\n  },\n  // Extract the original keyed object from the fragment opaque type. Warn if\n  // a plain object is passed here.\n  extract: function(fragment) {\n    if (\"production\" !== process.env.NODE_ENV) {\n      if (canWarnForReactFragment) {\n        if (!fragment[fragmentKey]) {\n          (\"production\" !== process.env.NODE_ENV ? warning(\n            didWarnForFragment(fragment),\n            'Any use of a keyed object should be wrapped in ' +\n            'React.addons.createFragment(object) before being passed as a ' +\n            'child.'\n          ) : null);\n          return fragment;\n        }\n        return fragment[fragmentKey];\n      }\n    }\n    return fragment;\n  },\n  // Check if this is a fragment and if so, extract the keyed object. If it\n  // is a fragment-like object, warn that it should be wrapped. Ignore if we\n  // can't determine what kind of object this is.\n  extractIfFragment: function(fragment) {\n    if (\"production\" !== process.env.NODE_ENV) {\n      if (canWarnForReactFragment) {\n        // If it is the opaque type, return the keyed object.\n        if (fragment[fragmentKey]) {\n          return fragment[fragmentKey];\n        }\n        // Otherwise, check each property if it has an element, if it does\n        // it is probably meant as a fragment, so we can warn early. Defer,\n        // the warning to extract.\n        for (var key in fragment) {\n          if (fragment.hasOwnProperty(key) &&\n              ReactElement.isValidElement(fragment[key])) {\n            // This looks like a fragment object, we should provide an\n            // early warning.\n            return ReactFragment.extract(fragment);\n          }\n        }\n      }\n    }\n    return fragment;\n  }\n};\n\nmodule.exports = ReactFragment;\n"]},"metadata":{},"sourceType":"script"}