{"ast":null,"code":"/**\n * Copyright 2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactUpdateQueue\n */\n'use strict';\n\nvar ReactLifeCycle = require(\"./ReactLifeCycle\");\n\nvar ReactCurrentOwner = require(\"./ReactCurrentOwner\");\n\nvar ReactElement = require(\"./ReactElement\");\n\nvar ReactInstanceMap = require(\"./ReactInstanceMap\");\n\nvar ReactUpdates = require(\"./ReactUpdates\");\n\nvar assign = require(\"./Object.assign\");\n\nvar invariant = require(\"./invariant\");\n\nvar warning = require(\"./warning\");\n\nfunction enqueueUpdate(internalInstance) {\n  if (internalInstance !== ReactLifeCycle.currentlyMountingInstance) {\n    // If we're in a componentWillMount handler, don't enqueue a rerender\n    // because ReactUpdates assumes we're in a browser context (which is\n    // wrong for server rendering) and we're about to do a render anyway.\n    // See bug in #1740.\n    ReactUpdates.enqueueUpdate(internalInstance);\n  }\n}\n\nfunction getInternalInstanceReadyForUpdate(publicInstance, callerName) {\n  \"production\" !== process.env.NODE_ENV ? invariant(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition ' + '(such as within `render`). Render methods should be a pure function ' + 'of props and state.', callerName) : invariant(ReactCurrentOwner.current == null);\n  var internalInstance = ReactInstanceMap.get(publicInstance);\n\n  if (!internalInstance) {\n    if (\"production\" !== process.env.NODE_ENV) {\n      // Only warn when we have a callerName. Otherwise we should be silent.\n      // We're probably calling from enqueueCallback. We don't want to warn\n      // there because we already warned for the corresponding lifecycle method.\n      \"production\" !== process.env.NODE_ENV ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted ' + 'component. This is a no-op.', callerName, callerName) : null;\n    }\n\n    return null;\n  }\n\n  if (internalInstance === ReactLifeCycle.currentlyUnmountingInstance) {\n    return null;\n  }\n\n  return internalInstance;\n}\n/**\n * ReactUpdateQueue allows for state updates to be scheduled into a later\n * reconciliation step.\n */\n\n\nvar ReactUpdateQueue = {\n  /**\n   * Enqueue a callback that will be executed after all the pending updates\n   * have processed.\n   *\n   * @param {ReactClass} publicInstance The instance to use as `this` context.\n   * @param {?function} callback Called after state is updated.\n   * @internal\n   */\n  enqueueCallback: function (publicInstance, callback) {\n    \"production\" !== process.env.NODE_ENV ? invariant(typeof callback === 'function', 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\\'t callable.') : invariant(typeof callback === 'function');\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance); // Previously we would throw an error if we didn't have an internal\n    // instance. Since we want to make it a no-op instead, we mirror the same\n    // behavior we have in other enqueue* methods.\n    // We also need to ignore callbacks in componentWillMount. See\n    // enqueueUpdates.\n\n    if (!internalInstance || internalInstance === ReactLifeCycle.currentlyMountingInstance) {\n      return null;\n    }\n\n    if (internalInstance._pendingCallbacks) {\n      internalInstance._pendingCallbacks.push(callback);\n    } else {\n      internalInstance._pendingCallbacks = [callback];\n    } // TODO: The callback here is ignored when setState is called from\n    // componentWillMount. Either fix it or disallow doing so completely in\n    // favor of getInitialState. Alternatively, we can disallow\n    // componentWillMount during server-side rendering.\n\n\n    enqueueUpdate(internalInstance);\n  },\n  enqueueCallbackInternal: function (internalInstance, callback) {\n    \"production\" !== process.env.NODE_ENV ? invariant(typeof callback === 'function', 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\\'t callable.') : invariant(typeof callback === 'function');\n\n    if (internalInstance._pendingCallbacks) {\n      internalInstance._pendingCallbacks.push(callback);\n    } else {\n      internalInstance._pendingCallbacks = [callback];\n    }\n\n    enqueueUpdate(internalInstance);\n  },\n\n  /**\n   * Forces an update. This should only be invoked when it is known with\n   * certainty that we are **not** in a DOM transaction.\n   *\n   * You may want to call this when you know that some deeper aspect of the\n   * component's state has changed but `setState` was not called.\n   *\n   * This will not invoke `shouldUpdateComponent`, but it will invoke\n   * `componentWillUpdate` and `componentDidUpdate`.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @internal\n   */\n  enqueueForceUpdate: function (publicInstance) {\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');\n\n    if (!internalInstance) {\n      return;\n    }\n\n    internalInstance._pendingForceUpdate = true;\n    enqueueUpdate(internalInstance);\n  },\n\n  /**\n   * Replaces all of the state. Always use this or `setState` to mutate state.\n   * You should treat `this.state` as immutable.\n   *\n   * There is no guarantee that `this.state` will be immediately updated, so\n   * accessing `this.state` after calling this method may return the old value.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} completeState Next state.\n   * @internal\n   */\n  enqueueReplaceState: function (publicInstance, completeState) {\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');\n\n    if (!internalInstance) {\n      return;\n    }\n\n    internalInstance._pendingStateQueue = [completeState];\n    internalInstance._pendingReplaceState = true;\n    enqueueUpdate(internalInstance);\n  },\n\n  /**\n   * Sets a subset of the state. This only exists because _pendingState is\n   * internal. This provides a merging strategy that is not available to deep\n   * properties which is confusing. TODO: Expose pendingState or don't use it\n   * during the merge.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialState Next partial state to be merged with state.\n   * @internal\n   */\n  enqueueSetState: function (publicInstance, partialState) {\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');\n\n    if (!internalInstance) {\n      return;\n    }\n\n    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);\n    queue.push(partialState);\n    enqueueUpdate(internalInstance);\n  },\n\n  /**\n   * Sets a subset of the props.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialProps Subset of the next props.\n   * @internal\n   */\n  enqueueSetProps: function (publicInstance, partialProps) {\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setProps');\n\n    if (!internalInstance) {\n      return;\n    }\n\n    \"production\" !== process.env.NODE_ENV ? invariant(internalInstance._isTopLevel, 'setProps(...): You called `setProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(internalInstance._isTopLevel); // Merge with the pending element if it exists, otherwise with existing\n    // element props.\n\n    var element = internalInstance._pendingElement || internalInstance._currentElement;\n    var props = assign({}, element.props, partialProps);\n    internalInstance._pendingElement = ReactElement.cloneAndReplaceProps(element, props);\n    enqueueUpdate(internalInstance);\n  },\n\n  /**\n   * Replaces all of the props.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} props New props.\n   * @internal\n   */\n  enqueueReplaceProps: function (publicInstance, props) {\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceProps');\n\n    if (!internalInstance) {\n      return;\n    }\n\n    \"production\" !== process.env.NODE_ENV ? invariant(internalInstance._isTopLevel, 'replaceProps(...): You called `replaceProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(internalInstance._isTopLevel); // Merge with the pending element if it exists, otherwise with existing\n    // element props.\n\n    var element = internalInstance._pendingElement || internalInstance._currentElement;\n    internalInstance._pendingElement = ReactElement.cloneAndReplaceProps(element, props);\n    enqueueUpdate(internalInstance);\n  },\n  enqueueElementInternal: function (internalInstance, newElement) {\n    internalInstance._pendingElement = newElement;\n    enqueueUpdate(internalInstance);\n  }\n};\nmodule.exports = ReactUpdateQueue;","map":{"version":3,"sources":["C:/Users/apollo/islamicpsychologyapi/node_modules/react/lib/ReactUpdateQueue.js"],"names":["ReactLifeCycle","require","ReactCurrentOwner","ReactElement","ReactInstanceMap","ReactUpdates","assign","invariant","warning","enqueueUpdate","internalInstance","currentlyMountingInstance","getInternalInstanceReadyForUpdate","publicInstance","callerName","process","env","NODE_ENV","current","get","currentlyUnmountingInstance","ReactUpdateQueue","enqueueCallback","callback","_pendingCallbacks","push","enqueueCallbackInternal","enqueueForceUpdate","_pendingForceUpdate","enqueueReplaceState","completeState","_pendingStateQueue","_pendingReplaceState","enqueueSetState","partialState","queue","enqueueSetProps","partialProps","_isTopLevel","element","_pendingElement","_currentElement","props","cloneAndReplaceProps","enqueueReplaceProps","enqueueElementInternal","newElement","module","exports"],"mappings":"AAAA;;;;;;;;;;AAWA;;AAEA,IAAIA,cAAc,GAAGC,OAAO,CAAC,kBAAD,CAA5B;;AACA,IAAIC,iBAAiB,GAAGD,OAAO,CAAC,qBAAD,CAA/B;;AACA,IAAIE,YAAY,GAAGF,OAAO,CAAC,gBAAD,CAA1B;;AACA,IAAIG,gBAAgB,GAAGH,OAAO,CAAC,oBAAD,CAA9B;;AACA,IAAII,YAAY,GAAGJ,OAAO,CAAC,gBAAD,CAA1B;;AAEA,IAAIK,MAAM,GAAGL,OAAO,CAAC,iBAAD,CAApB;;AACA,IAAIM,SAAS,GAAGN,OAAO,CAAC,aAAD,CAAvB;;AACA,IAAIO,OAAO,GAAGP,OAAO,CAAC,WAAD,CAArB;;AAEA,SAASQ,aAAT,CAAuBC,gBAAvB,EAAyC;AACvC,MAAIA,gBAAgB,KAAKV,cAAc,CAACW,yBAAxC,EAAmE;AACjE;AACA;AACA;AACA;AACAN,IAAAA,YAAY,CAACI,aAAb,CAA2BC,gBAA3B;AACD;AACF;;AAED,SAASE,iCAAT,CAA2CC,cAA3C,EAA2DC,UAA3D,EAAuE;AACpE,mBAAiBC,OAAO,CAACC,GAAR,CAAYC,QAA7B,GAAwCV,SAAS,CAChDL,iBAAiB,CAACgB,OAAlB,IAA6B,IADmB,EAEhD,gEACA,sEADA,GAEA,qBAJgD,EAKhDJ,UALgD,CAAjD,GAMGP,SAAS,CAACL,iBAAiB,CAACgB,OAAlB,IAA6B,IAA9B,CANb;AAQA,MAAIR,gBAAgB,GAAGN,gBAAgB,CAACe,GAAjB,CAAqBN,cAArB,CAAvB;;AACA,MAAI,CAACH,gBAAL,EAAuB;AACrB,QAAI,iBAAiBK,OAAO,CAACC,GAAR,CAAYC,QAAjC,EAA2C;AACzC;AACA;AACA;AACC,uBAAiBF,OAAO,CAACC,GAAR,CAAYC,QAA7B,GAAwCT,OAAO,CAC9C,CAACM,UAD6C,EAE9C,+DACA,qDADA,GAEA,6BAJ8C,EAK9CA,UAL8C,EAM9CA,UAN8C,CAA/C,GAOG,IAPJ;AAQD;;AACD,WAAO,IAAP;AACD;;AAED,MAAIJ,gBAAgB,KAAKV,cAAc,CAACoB,2BAAxC,EAAqE;AACnE,WAAO,IAAP;AACD;;AAED,SAAOV,gBAAP;AACD;AAED;;;;;;AAIA,IAAIW,gBAAgB,GAAG;AAErB;;;;;;;;AAQAC,EAAAA,eAAe,EAAE,UAAST,cAAT,EAAyBU,QAAzB,EAAmC;AACjD,qBAAiBR,OAAO,CAACC,GAAR,CAAYC,QAA7B,GAAwCV,SAAS,CAChD,OAAOgB,QAAP,KAAoB,UAD4B,EAEhD,kEACA,oEADA,GAEA,kBAJgD,CAAjD,GAKGhB,SAAS,CAAC,OAAOgB,QAAP,KAAoB,UAArB,CALb;AAMA,QAAIb,gBAAgB,GAAGE,iCAAiC,CAACC,cAAD,CAAxD,CAPkD,CASlD;AACA;AACA;AACA;AACA;;AACA,QAAI,CAACH,gBAAD,IACAA,gBAAgB,KAAKV,cAAc,CAACW,yBADxC,EACmE;AACjE,aAAO,IAAP;AACD;;AAED,QAAID,gBAAgB,CAACc,iBAArB,EAAwC;AACtCd,MAAAA,gBAAgB,CAACc,iBAAjB,CAAmCC,IAAnC,CAAwCF,QAAxC;AACD,KAFD,MAEO;AACLb,MAAAA,gBAAgB,CAACc,iBAAjB,GAAqC,CAACD,QAAD,CAArC;AACD,KAvBiD,CAwBlD;AACA;AACA;AACA;;;AACAd,IAAAA,aAAa,CAACC,gBAAD,CAAb;AACD,GAvCoB;AAyCrBgB,EAAAA,uBAAuB,EAAE,UAAShB,gBAAT,EAA2Ba,QAA3B,EAAqC;AAC3D,qBAAiBR,OAAO,CAACC,GAAR,CAAYC,QAA7B,GAAwCV,SAAS,CAChD,OAAOgB,QAAP,KAAoB,UAD4B,EAEhD,kEACA,oEADA,GAEA,kBAJgD,CAAjD,GAKGhB,SAAS,CAAC,OAAOgB,QAAP,KAAoB,UAArB,CALb;;AAMA,QAAIb,gBAAgB,CAACc,iBAArB,EAAwC;AACtCd,MAAAA,gBAAgB,CAACc,iBAAjB,CAAmCC,IAAnC,CAAwCF,QAAxC;AACD,KAFD,MAEO;AACLb,MAAAA,gBAAgB,CAACc,iBAAjB,GAAqC,CAACD,QAAD,CAArC;AACD;;AACDd,IAAAA,aAAa,CAACC,gBAAD,CAAb;AACD,GAtDoB;;AAwDrB;;;;;;;;;;;;;AAaAiB,EAAAA,kBAAkB,EAAE,UAASd,cAAT,EAAyB;AAC3C,QAAIH,gBAAgB,GAAGE,iCAAiC,CACtDC,cADsD,EAEtD,aAFsD,CAAxD;;AAKA,QAAI,CAACH,gBAAL,EAAuB;AACrB;AACD;;AAEDA,IAAAA,gBAAgB,CAACkB,mBAAjB,GAAuC,IAAvC;AAEAnB,IAAAA,aAAa,CAACC,gBAAD,CAAb;AACD,GAlFoB;;AAoFrB;;;;;;;;;;;AAWAmB,EAAAA,mBAAmB,EAAE,UAAShB,cAAT,EAAyBiB,aAAzB,EAAwC;AAC3D,QAAIpB,gBAAgB,GAAGE,iCAAiC,CACtDC,cADsD,EAEtD,cAFsD,CAAxD;;AAKA,QAAI,CAACH,gBAAL,EAAuB;AACrB;AACD;;AAEDA,IAAAA,gBAAgB,CAACqB,kBAAjB,GAAsC,CAACD,aAAD,CAAtC;AACApB,IAAAA,gBAAgB,CAACsB,oBAAjB,GAAwC,IAAxC;AAEAvB,IAAAA,aAAa,CAACC,gBAAD,CAAb;AACD,GA7GoB;;AA+GrB;;;;;;;;;;AAUAuB,EAAAA,eAAe,EAAE,UAASpB,cAAT,EAAyBqB,YAAzB,EAAuC;AACtD,QAAIxB,gBAAgB,GAAGE,iCAAiC,CACtDC,cADsD,EAEtD,UAFsD,CAAxD;;AAKA,QAAI,CAACH,gBAAL,EAAuB;AACrB;AACD;;AAED,QAAIyB,KAAK,GACPzB,gBAAgB,CAACqB,kBAAjB,KACCrB,gBAAgB,CAACqB,kBAAjB,GAAsC,EADvC,CADF;AAGAI,IAAAA,KAAK,CAACV,IAAN,CAAWS,YAAX;AAEAzB,IAAAA,aAAa,CAACC,gBAAD,CAAb;AACD,GAzIoB;;AA2IrB;;;;;;;AAOA0B,EAAAA,eAAe,EAAE,UAASvB,cAAT,EAAyBwB,YAAzB,EAAuC;AACtD,QAAI3B,gBAAgB,GAAGE,iCAAiC,CACtDC,cADsD,EAEtD,UAFsD,CAAxD;;AAKA,QAAI,CAACH,gBAAL,EAAuB;AACrB;AACD;;AAEA,qBAAiBK,OAAO,CAACC,GAAR,CAAYC,QAA7B,GAAwCV,SAAS,CAChDG,gBAAgB,CAAC4B,WAD+B,EAEhD,+CACA,oEADA,GAEA,qEAFA,GAGA,sEAHA,GAIA,sBANgD,CAAjD,GAOG/B,SAAS,CAACG,gBAAgB,CAAC4B,WAAlB,CAPb,CAVsD,CAmBtD;AACA;;AACA,QAAIC,OAAO,GAAG7B,gBAAgB,CAAC8B,eAAjB,IACA9B,gBAAgB,CAAC+B,eAD/B;AAEA,QAAIC,KAAK,GAAGpC,MAAM,CAAC,EAAD,EAAKiC,OAAO,CAACG,KAAb,EAAoBL,YAApB,CAAlB;AACA3B,IAAAA,gBAAgB,CAAC8B,eAAjB,GAAmCrC,YAAY,CAACwC,oBAAb,CACjCJ,OADiC,EAEjCG,KAFiC,CAAnC;AAKAjC,IAAAA,aAAa,CAACC,gBAAD,CAAb;AACD,GAhLoB;;AAkLrB;;;;;;;AAOAkC,EAAAA,mBAAmB,EAAE,UAAS/B,cAAT,EAAyB6B,KAAzB,EAAgC;AACnD,QAAIhC,gBAAgB,GAAGE,iCAAiC,CACtDC,cADsD,EAEtD,cAFsD,CAAxD;;AAKA,QAAI,CAACH,gBAAL,EAAuB;AACrB;AACD;;AAEA,qBAAiBK,OAAO,CAACC,GAAR,CAAYC,QAA7B,GAAwCV,SAAS,CAChDG,gBAAgB,CAAC4B,WAD+B,EAEhD,uDACA,oEADA,GAEA,qEAFA,GAGA,sEAHA,GAIA,sBANgD,CAAjD,GAOG/B,SAAS,CAACG,gBAAgB,CAAC4B,WAAlB,CAPb,CAVmD,CAmBnD;AACA;;AACA,QAAIC,OAAO,GAAG7B,gBAAgB,CAAC8B,eAAjB,IACA9B,gBAAgB,CAAC+B,eAD/B;AAEA/B,IAAAA,gBAAgB,CAAC8B,eAAjB,GAAmCrC,YAAY,CAACwC,oBAAb,CACjCJ,OADiC,EAEjCG,KAFiC,CAAnC;AAKAjC,IAAAA,aAAa,CAACC,gBAAD,CAAb;AACD,GAtNoB;AAwNrBmC,EAAAA,sBAAsB,EAAE,UAASnC,gBAAT,EAA2BoC,UAA3B,EAAuC;AAC7DpC,IAAAA,gBAAgB,CAAC8B,eAAjB,GAAmCM,UAAnC;AACArC,IAAAA,aAAa,CAACC,gBAAD,CAAb;AACD;AA3NoB,CAAvB;AA+NAqC,MAAM,CAACC,OAAP,GAAiB3B,gBAAjB","sourcesContent":["/**\n * Copyright 2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactUpdateQueue\n */\n\n'use strict';\n\nvar ReactLifeCycle = require(\"./ReactLifeCycle\");\nvar ReactCurrentOwner = require(\"./ReactCurrentOwner\");\nvar ReactElement = require(\"./ReactElement\");\nvar ReactInstanceMap = require(\"./ReactInstanceMap\");\nvar ReactUpdates = require(\"./ReactUpdates\");\n\nvar assign = require(\"./Object.assign\");\nvar invariant = require(\"./invariant\");\nvar warning = require(\"./warning\");\n\nfunction enqueueUpdate(internalInstance) {\n  if (internalInstance !== ReactLifeCycle.currentlyMountingInstance) {\n    // If we're in a componentWillMount handler, don't enqueue a rerender\n    // because ReactUpdates assumes we're in a browser context (which is\n    // wrong for server rendering) and we're about to do a render anyway.\n    // See bug in #1740.\n    ReactUpdates.enqueueUpdate(internalInstance);\n  }\n}\n\nfunction getInternalInstanceReadyForUpdate(publicInstance, callerName) {\n  (\"production\" !== process.env.NODE_ENV ? invariant(\n    ReactCurrentOwner.current == null,\n    '%s(...): Cannot update during an existing state transition ' +\n    '(such as within `render`). Render methods should be a pure function ' +\n    'of props and state.',\n    callerName\n  ) : invariant(ReactCurrentOwner.current == null));\n\n  var internalInstance = ReactInstanceMap.get(publicInstance);\n  if (!internalInstance) {\n    if (\"production\" !== process.env.NODE_ENV) {\n      // Only warn when we have a callerName. Otherwise we should be silent.\n      // We're probably calling from enqueueCallback. We don't want to warn\n      // there because we already warned for the corresponding lifecycle method.\n      (\"production\" !== process.env.NODE_ENV ? warning(\n        !callerName,\n        '%s(...): Can only update a mounted or mounting component. ' +\n        'This usually means you called %s() on an unmounted ' +\n        'component. This is a no-op.',\n        callerName,\n        callerName\n      ) : null);\n    }\n    return null;\n  }\n\n  if (internalInstance === ReactLifeCycle.currentlyUnmountingInstance) {\n    return null;\n  }\n\n  return internalInstance;\n}\n\n/**\n * ReactUpdateQueue allows for state updates to be scheduled into a later\n * reconciliation step.\n */\nvar ReactUpdateQueue = {\n\n  /**\n   * Enqueue a callback that will be executed after all the pending updates\n   * have processed.\n   *\n   * @param {ReactClass} publicInstance The instance to use as `this` context.\n   * @param {?function} callback Called after state is updated.\n   * @internal\n   */\n  enqueueCallback: function(publicInstance, callback) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      typeof callback === 'function',\n      'enqueueCallback(...): You called `setProps`, `replaceProps`, ' +\n      '`setState`, `replaceState`, or `forceUpdate` with a callback that ' +\n      'isn\\'t callable.'\n    ) : invariant(typeof callback === 'function'));\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);\n\n    // Previously we would throw an error if we didn't have an internal\n    // instance. Since we want to make it a no-op instead, we mirror the same\n    // behavior we have in other enqueue* methods.\n    // We also need to ignore callbacks in componentWillMount. See\n    // enqueueUpdates.\n    if (!internalInstance ||\n        internalInstance === ReactLifeCycle.currentlyMountingInstance) {\n      return null;\n    }\n\n    if (internalInstance._pendingCallbacks) {\n      internalInstance._pendingCallbacks.push(callback);\n    } else {\n      internalInstance._pendingCallbacks = [callback];\n    }\n    // TODO: The callback here is ignored when setState is called from\n    // componentWillMount. Either fix it or disallow doing so completely in\n    // favor of getInitialState. Alternatively, we can disallow\n    // componentWillMount during server-side rendering.\n    enqueueUpdate(internalInstance);\n  },\n\n  enqueueCallbackInternal: function(internalInstance, callback) {\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      typeof callback === 'function',\n      'enqueueCallback(...): You called `setProps`, `replaceProps`, ' +\n      '`setState`, `replaceState`, or `forceUpdate` with a callback that ' +\n      'isn\\'t callable.'\n    ) : invariant(typeof callback === 'function'));\n    if (internalInstance._pendingCallbacks) {\n      internalInstance._pendingCallbacks.push(callback);\n    } else {\n      internalInstance._pendingCallbacks = [callback];\n    }\n    enqueueUpdate(internalInstance);\n  },\n\n  /**\n   * Forces an update. This should only be invoked when it is known with\n   * certainty that we are **not** in a DOM transaction.\n   *\n   * You may want to call this when you know that some deeper aspect of the\n   * component's state has changed but `setState` was not called.\n   *\n   * This will not invoke `shouldUpdateComponent`, but it will invoke\n   * `componentWillUpdate` and `componentDidUpdate`.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @internal\n   */\n  enqueueForceUpdate: function(publicInstance) {\n    var internalInstance = getInternalInstanceReadyForUpdate(\n      publicInstance,\n      'forceUpdate'\n    );\n\n    if (!internalInstance) {\n      return;\n    }\n\n    internalInstance._pendingForceUpdate = true;\n\n    enqueueUpdate(internalInstance);\n  },\n\n  /**\n   * Replaces all of the state. Always use this or `setState` to mutate state.\n   * You should treat `this.state` as immutable.\n   *\n   * There is no guarantee that `this.state` will be immediately updated, so\n   * accessing `this.state` after calling this method may return the old value.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} completeState Next state.\n   * @internal\n   */\n  enqueueReplaceState: function(publicInstance, completeState) {\n    var internalInstance = getInternalInstanceReadyForUpdate(\n      publicInstance,\n      'replaceState'\n    );\n\n    if (!internalInstance) {\n      return;\n    }\n\n    internalInstance._pendingStateQueue = [completeState];\n    internalInstance._pendingReplaceState = true;\n\n    enqueueUpdate(internalInstance);\n  },\n\n  /**\n   * Sets a subset of the state. This only exists because _pendingState is\n   * internal. This provides a merging strategy that is not available to deep\n   * properties which is confusing. TODO: Expose pendingState or don't use it\n   * during the merge.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialState Next partial state to be merged with state.\n   * @internal\n   */\n  enqueueSetState: function(publicInstance, partialState) {\n    var internalInstance = getInternalInstanceReadyForUpdate(\n      publicInstance,\n      'setState'\n    );\n\n    if (!internalInstance) {\n      return;\n    }\n\n    var queue =\n      internalInstance._pendingStateQueue ||\n      (internalInstance._pendingStateQueue = []);\n    queue.push(partialState);\n\n    enqueueUpdate(internalInstance);\n  },\n\n  /**\n   * Sets a subset of the props.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialProps Subset of the next props.\n   * @internal\n   */\n  enqueueSetProps: function(publicInstance, partialProps) {\n    var internalInstance = getInternalInstanceReadyForUpdate(\n      publicInstance,\n      'setProps'\n    );\n\n    if (!internalInstance) {\n      return;\n    }\n\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      internalInstance._isTopLevel,\n      'setProps(...): You called `setProps` on a ' +\n      'component with a parent. This is an anti-pattern since props will ' +\n      'get reactively updated when rendered. Instead, change the owner\\'s ' +\n      '`render` method to pass the correct value as props to the component ' +\n      'where it is created.'\n    ) : invariant(internalInstance._isTopLevel));\n\n    // Merge with the pending element if it exists, otherwise with existing\n    // element props.\n    var element = internalInstance._pendingElement ||\n                  internalInstance._currentElement;\n    var props = assign({}, element.props, partialProps);\n    internalInstance._pendingElement = ReactElement.cloneAndReplaceProps(\n      element,\n      props\n    );\n\n    enqueueUpdate(internalInstance);\n  },\n\n  /**\n   * Replaces all of the props.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} props New props.\n   * @internal\n   */\n  enqueueReplaceProps: function(publicInstance, props) {\n    var internalInstance = getInternalInstanceReadyForUpdate(\n      publicInstance,\n      'replaceProps'\n    );\n\n    if (!internalInstance) {\n      return;\n    }\n\n    (\"production\" !== process.env.NODE_ENV ? invariant(\n      internalInstance._isTopLevel,\n      'replaceProps(...): You called `replaceProps` on a ' +\n      'component with a parent. This is an anti-pattern since props will ' +\n      'get reactively updated when rendered. Instead, change the owner\\'s ' +\n      '`render` method to pass the correct value as props to the component ' +\n      'where it is created.'\n    ) : invariant(internalInstance._isTopLevel));\n\n    // Merge with the pending element if it exists, otherwise with existing\n    // element props.\n    var element = internalInstance._pendingElement ||\n                  internalInstance._currentElement;\n    internalInstance._pendingElement = ReactElement.cloneAndReplaceProps(\n      element,\n      props\n    );\n\n    enqueueUpdate(internalInstance);\n  },\n\n  enqueueElementInternal: function(internalInstance, newElement) {\n    internalInstance._pendingElement = newElement;\n    enqueueUpdate(internalInstance);\n  }\n\n};\n\nmodule.exports = ReactUpdateQueue;\n"]},"metadata":{},"sourceType":"script"}