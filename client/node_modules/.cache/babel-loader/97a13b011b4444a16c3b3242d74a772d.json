{"ast":null,"code":"const Busboy = require('busboy');\n\nconst UploadTimer = require('./uploadtimer');\n\nconst fileFactory = require('./fileFactory');\n\nconst memHandler = require('./memHandler');\n\nconst tempFileHandler = require('./tempFileHandler');\n\nconst processNested = require('./processNested');\n\nconst {\n  isFunc,\n  debugLog,\n  buildFields,\n  buildOptions,\n  parseFileName\n} = require('./utilities');\n\nconst waitFlushProperty = Symbol('wait flush property symbol');\n/**\n * Processes multipart request\n * Builds a req.body object for fields\n * Builds a req.files object for files\n * @param  {Object}   options expressFileupload and Busboy options\n * @param  {Object}   req     Express request object\n * @param  {Object}   res     Express response object\n * @param  {Function} next    Express next method\n * @return {void}\n */\n\nmodule.exports = (options, req, res, next) => {\n  req.files = null; // Build busboy options and init busboy instance.\n\n  const busboyOptions = buildOptions(options, {\n    headers: req.headers\n  });\n  const busboy = new Busboy(busboyOptions); // Close connection with specified reason and http code, default: 400 Bad Request.\n\n  const closeConnection = (code, reason) => {\n    req.unpipe(busboy);\n    res.writeHead(code || 400, {\n      Connection: 'close'\n    });\n    res.end(reason || 'Bad Request');\n  }; // Build multipart req.body fields\n\n\n  busboy.on('field', (field, val) => req.body = buildFields(req.body, field, val)); // Build req.files fields\n\n  busboy.on('file', (field, file, name, encoding, mime) => {\n    // Parse file name(cutting huge names, decoding, etc..).\n    const filename = parseFileName(options, name); // Define methods and handlers for upload process.\n\n    const {\n      dataHandler,\n      getFilePath,\n      getFileSize,\n      getHash,\n      complete,\n      cleanup,\n      getWritePromise\n    } = options.useTempFiles ? tempFileHandler(options, field, filename) // Upload into temporary file.\n    : memHandler(options, field, filename); // Upload into RAM.\n    // Define upload timer.\n\n    const uploadTimer = new UploadTimer(options.uploadTimeout, () => {\n      file.removeAllListeners('data');\n      file.resume(); // After destroy an error event will be emitted and file clean up will be done.\n\n      file.destroy(new Error(`Upload timeout ${field}->${filename}, bytes:${getFileSize()}`));\n    });\n    file.on('limit', () => {\n      debugLog(options, `Size limit reached for ${field}->${filename}, bytes:${getFileSize()}`); // Reset upload timer in case of file limit reached.\n\n      uploadTimer.clear(); // Run a user defined limit handler if it has been set.\n\n      if (isFunc(options.limitHandler)) return options.limitHandler(req, res, next); // Close connection with 413 code and do cleanup if abortOnLimit set(default: false).\n\n      if (options.abortOnLimit) {\n        debugLog(options, `Aborting upload because of size limit ${field}->${filename}.`);\n        closeConnection(413, options.responseOnLimit);\n        cleanup();\n      }\n    });\n    file.on('data', data => {\n      uploadTimer.set(); // Refresh upload timer each time new data chunk came.\n\n      dataHandler(data); // Handle new piece of data.\n    });\n    file.on('end', () => {\n      const size = getFileSize(); // Debug logging for file upload ending.\n\n      debugLog(options, `Upload finished ${field}->${filename}, bytes:${size}`); // Reset upload timer in case of end event.\n\n      uploadTimer.clear(); // See https://github.com/richardgirges/express-fileupload/issues/191\n      // Do not add file instance to the req.files if original name and size are empty.\n      // Empty name and zero size indicates empty file field in the posted form.\n\n      if (!name && size === 0) {\n        if (options.useTempFiles) {\n          cleanup();\n          debugLog(options, `Removing the empty file ${field}->${filename}`);\n        }\n\n        return debugLog(options, `Don't add file instance if original name and size are empty`);\n      }\n\n      req.files = buildFields(req.files, field, fileFactory({\n        buffer: complete(),\n        name: filename,\n        tempFilePath: getFilePath(),\n        hash: getHash(),\n        size,\n        encoding,\n        truncated: file.truncated,\n        mimetype: mime\n      }, options));\n\n      if (!req[waitFlushProperty]) {\n        req[waitFlushProperty] = [];\n      }\n\n      req[waitFlushProperty].push(getWritePromise());\n    });\n    file.on('error', err => {\n      uploadTimer.clear(); // Reset upload timer in case of errors.\n\n      debugLog(options, err);\n      cleanup();\n      next();\n    }); // Debug logging for a new file upload.\n\n    debugLog(options, `New upload started ${field}->${filename}, bytes:${getFileSize()}`); // Set new upload timeout for a new file.\n\n    uploadTimer.set();\n  });\n  busboy.on('finish', () => {\n    debugLog(options, `Busboy finished parsing request.`);\n\n    if (options.parseNested) {\n      req.body = processNested(req.body);\n      req.files = processNested(req.files);\n    }\n\n    if (!req[waitFlushProperty]) return next();\n    Promise.all(req[waitFlushProperty]).then(() => {\n      delete req[waitFlushProperty];\n      next();\n    }).catch(err => {\n      delete req[waitFlushProperty];\n      debugLog(options, `Error while waiting files flush: ${err}`);\n      next(err);\n    });\n  });\n  busboy.on('error', err => {\n    debugLog(options, `Busboy error`);\n    next(err);\n  });\n  req.pipe(busboy);\n};","map":{"version":3,"sources":["C:/Users/apollo/IPS/node_modules/express-fileupload/lib/processMultipart.js"],"names":["Busboy","require","UploadTimer","fileFactory","memHandler","tempFileHandler","processNested","isFunc","debugLog","buildFields","buildOptions","parseFileName","waitFlushProperty","Symbol","module","exports","options","req","res","next","files","busboyOptions","headers","busboy","closeConnection","code","reason","unpipe","writeHead","Connection","end","on","field","val","body","file","name","encoding","mime","filename","dataHandler","getFilePath","getFileSize","getHash","complete","cleanup","getWritePromise","useTempFiles","uploadTimer","uploadTimeout","removeAllListeners","resume","destroy","Error","clear","limitHandler","abortOnLimit","responseOnLimit","data","set","size","buffer","tempFilePath","hash","truncated","mimetype","push","err","parseNested","Promise","all","then","catch","pipe"],"mappings":"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","sourcesContent":["const Busboy = require('busboy');\nconst UploadTimer = require('./uploadtimer');\nconst fileFactory = require('./fileFactory');\nconst memHandler = require('./memHandler');\nconst tempFileHandler = require('./tempFileHandler');\nconst processNested = require('./processNested');\nconst {\n  isFunc,\n  debugLog,\n  buildFields,\n  buildOptions,\n  parseFileName\n} = require('./utilities');\n\nconst waitFlushProperty = Symbol('wait flush property symbol');\n\n/**\n * Processes multipart request\n * Builds a req.body object for fields\n * Builds a req.files object for files\n * @param  {Object}   options expressFileupload and Busboy options\n * @param  {Object}   req     Express request object\n * @param  {Object}   res     Express response object\n * @param  {Function} next    Express next method\n * @return {void}\n */\nmodule.exports = (options, req, res, next) => {\n  req.files = null;\n\n  // Build busboy options and init busboy instance.\n  const busboyOptions = buildOptions(options, { headers: req.headers });\n  const busboy = new Busboy(busboyOptions);\n\n  // Close connection with specified reason and http code, default: 400 Bad Request.\n  const closeConnection = (code, reason) => {\n    req.unpipe(busboy);\n    res.writeHead(code || 400, { Connection: 'close' });\n    res.end(reason || 'Bad Request');\n  };\n\n  // Build multipart req.body fields\n  busboy.on('field', (field, val) => req.body = buildFields(req.body, field, val));\n\n  // Build req.files fields\n  busboy.on('file', (field, file, name, encoding, mime) => {\n    // Parse file name(cutting huge names, decoding, etc..).\n    const filename = parseFileName(options, name);\n    // Define methods and handlers for upload process.\n    const {\n      dataHandler,\n      getFilePath,\n      getFileSize,\n      getHash,\n      complete,\n      cleanup,\n      getWritePromise\n    } = options.useTempFiles\n      ? tempFileHandler(options, field, filename) // Upload into temporary file.\n      : memHandler(options, field, filename);     // Upload into RAM.\n    // Define upload timer.\n    const uploadTimer = new UploadTimer(options.uploadTimeout, () => {\n      file.removeAllListeners('data');\n      file.resume();\n      // After destroy an error event will be emitted and file clean up will be done.\n      file.destroy(new Error(`Upload timeout ${field}->${filename}, bytes:${getFileSize()}`));\n    });\n\n    file.on('limit', () => {\n      debugLog(options, `Size limit reached for ${field}->${filename}, bytes:${getFileSize()}`);\n      // Reset upload timer in case of file limit reached.\n      uploadTimer.clear();\n      // Run a user defined limit handler if it has been set.\n      if (isFunc(options.limitHandler)) return options.limitHandler(req, res, next);\n      // Close connection with 413 code and do cleanup if abortOnLimit set(default: false).\n      if (options.abortOnLimit) {\n        debugLog(options, `Aborting upload because of size limit ${field}->${filename}.`);\n        closeConnection(413, options.responseOnLimit);\n        cleanup();\n      }\n    });\n\n    file.on('data', (data) => {\n      uploadTimer.set(); // Refresh upload timer each time new data chunk came.\n      dataHandler(data); // Handle new piece of data.\n    });\n\n    file.on('end', () => {\n      const size = getFileSize();\n      // Debug logging for file upload ending.\n      debugLog(options, `Upload finished ${field}->${filename}, bytes:${size}`);\n      // Reset upload timer in case of end event.\n      uploadTimer.clear();\n      // See https://github.com/richardgirges/express-fileupload/issues/191\n      // Do not add file instance to the req.files if original name and size are empty.\n      // Empty name and zero size indicates empty file field in the posted form.\n      if (!name && size === 0) {\n        if (options.useTempFiles) {\n          cleanup();\n          debugLog(options, `Removing the empty file ${field}->${filename}`);\n        }\n        return debugLog(options, `Don't add file instance if original name and size are empty`);\n      }\n      req.files = buildFields(req.files, field, fileFactory({\n        buffer: complete(),\n        name: filename,\n        tempFilePath: getFilePath(),\n        hash: getHash(),\n        size,\n        encoding,\n        truncated: file.truncated,\n        mimetype: mime\n      }, options));\n\n      if (!req[waitFlushProperty]) {\n        req[waitFlushProperty] = [];\n      }\n      req[waitFlushProperty].push(getWritePromise());\n    });\n\n    file.on('error', (err) => {\n      uploadTimer.clear(); // Reset upload timer in case of errors.\n      debugLog(options, err);\n      cleanup();\n      next();\n    });\n\n    // Debug logging for a new file upload.\n    debugLog(options, `New upload started ${field}->${filename}, bytes:${getFileSize()}`);\n    // Set new upload timeout for a new file.\n    uploadTimer.set();\n  });\n\n  busboy.on('finish', () => {\n    debugLog(options, `Busboy finished parsing request.`);\n    if (options.parseNested) {\n      req.body = processNested(req.body);\n      req.files = processNested(req.files);\n    }\n\n    if (!req[waitFlushProperty]) return next();\n    Promise.all(req[waitFlushProperty])\n      .then(() => {\n        delete req[waitFlushProperty];\n        next();\n      }).catch(err => {\n        delete req[waitFlushProperty];\n        debugLog(options, `Error while waiting files flush: ${err}`);\n        next(err);\n      });\n  });\n\n  busboy.on('error', (err) => {\n    debugLog(options, `Busboy error`);\n    next(err);\n  });\n\n  req.pipe(busboy);\n};\n"]},"metadata":{},"sourceType":"script"}