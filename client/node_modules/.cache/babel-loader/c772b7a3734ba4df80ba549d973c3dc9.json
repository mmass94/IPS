{"ast":null,"code":"const fs = require('fs');\n\nconst path = require('path');\n\nconst crypto = require('crypto');\n\nconst {\n  debugLog,\n  checkAndMakeDir,\n  getTempFilename,\n  deleteFile\n} = require('./utilities');\n\nmodule.exports = (options, fieldname, filename) => {\n  const dir = path.normalize(options.tempFileDir);\n  const tempFilePath = path.join(dir, getTempFilename());\n  checkAndMakeDir({\n    createParentPath: true\n  }, tempFilePath);\n  debugLog(options, `Temporary file path is ${tempFilePath}`);\n  const hash = crypto.createHash('md5');\n  let fileSize = 0;\n  let completed = false;\n  debugLog(options, `Opening write stream for ${fieldname}->${filename}...`);\n  const writeStream = fs.createWriteStream(tempFilePath);\n  const writePromise = new Promise((resolve, reject) => {\n    writeStream.on('finish', () => resolve());\n    writeStream.on('error', err => {\n      debugLog(options, `Error write temp file: ${err}`);\n      reject(err);\n    });\n  });\n  return {\n    dataHandler: data => {\n      if (completed === true) {\n        debugLog(options, `Error: got ${fieldname}->${filename} data chunk for completed upload!`);\n        return;\n      }\n\n      writeStream.write(data);\n      hash.update(data);\n      fileSize += data.length;\n      debugLog(options, `Uploading ${fieldname}->${filename}, bytes:${fileSize}...`);\n    },\n    getFilePath: () => tempFilePath,\n    getFileSize: () => fileSize,\n    getHash: () => hash.digest('hex'),\n    complete: () => {\n      completed = true;\n      debugLog(options, `Upload ${fieldname}->${filename} completed, bytes:${fileSize}.`);\n      if (writeStream !== false) writeStream.end(); // Return empty buff since data was uploaded into a temp file.\n\n      return Buffer.concat([]);\n    },\n    cleanup: () => {\n      completed = true;\n      debugLog(options, `Cleaning up temporary file ${tempFilePath}...`);\n      writeStream.end();\n      deleteFile(tempFilePath, err => err ? debugLog(options, `Cleaning up temporary file ${tempFilePath} failed: ${err}`) : debugLog(options, `Cleaning up temporary file ${tempFilePath} done.`));\n    },\n    getWritePromise: () => writePromise\n  };\n};","map":{"version":3,"sources":["C:/Users/apollo/IPS/node_modules/express-fileupload/lib/tempFileHandler.js"],"names":["fs","require","path","crypto","debugLog","checkAndMakeDir","getTempFilename","deleteFile","module","exports","options","fieldname","filename","dir","normalize","tempFileDir","tempFilePath","join","createParentPath","hash","createHash","fileSize","completed","writeStream","createWriteStream","writePromise","Promise","resolve","reject","on","err","dataHandler","data","write","update","length","getFilePath","getFileSize","getHash","digest","complete","end","Buffer","concat","cleanup","getWritePromise"],"mappings":"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","sourcesContent":["const fs = require('fs');\nconst path = require('path');\nconst crypto = require('crypto');\nconst {\n  debugLog,\n  checkAndMakeDir,\n  getTempFilename,\n  deleteFile\n} = require('./utilities');\n\nmodule.exports = (options, fieldname, filename) => {\n  const dir = path.normalize(options.tempFileDir);\n  const tempFilePath = path.join(dir, getTempFilename());\n  checkAndMakeDir({ createParentPath: true }, tempFilePath);\n\n  debugLog(options, `Temporary file path is ${tempFilePath}`);\n \n  const hash = crypto.createHash('md5');\n  let fileSize = 0;\n  let completed = false;\n\n  debugLog(options, `Opening write stream for ${fieldname}->${filename}...`);\n  const writeStream = fs.createWriteStream(tempFilePath);\n  const writePromise = new Promise((resolve, reject) => {\n    writeStream.on('finish', () => resolve());\n    writeStream.on('error', (err) => {\n      debugLog(options, `Error write temp file: ${err}`);\n      reject(err);\n    });\n  });\n\n  return {\n    dataHandler: (data) => {\n      if (completed === true) {\n        debugLog(options, `Error: got ${fieldname}->${filename} data chunk for completed upload!`);\n        return;\n      }\n      writeStream.write(data);\n      hash.update(data);\n      fileSize += data.length;\n      debugLog(options, `Uploading ${fieldname}->${filename}, bytes:${fileSize}...`);\n    },\n    getFilePath: () => tempFilePath,\n    getFileSize: () => fileSize,\n    getHash: () => hash.digest('hex'),\n    complete: () => {\n      completed = true;\n      debugLog(options, `Upload ${fieldname}->${filename} completed, bytes:${fileSize}.`);\n      if (writeStream !== false) writeStream.end();\n      // Return empty buff since data was uploaded into a temp file.\n      return Buffer.concat([]);\n    },\n    cleanup: () => {\n      completed = true;\n      debugLog(options, `Cleaning up temporary file ${tempFilePath}...`);\n      writeStream.end();\n      deleteFile(tempFilePath, err => (err \n        ? debugLog(options, `Cleaning up temporary file ${tempFilePath} failed: ${err}`)\n        : debugLog(options, `Cleaning up temporary file ${tempFilePath} done.`)\n      ));\n    },\n    getWritePromise: () => writePromise\n  };\n};\n"]},"metadata":{},"sourceType":"script"}